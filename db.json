{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME.txt","path":"CNAME.txt","modified":1,"renderable":0},{"_id":"source/images/css.gif","path":"images/css.gif","modified":1,"renderable":0},{"_id":"source/images/html5-layout.jpg","path":"images/html5-layout.jpg","modified":1,"renderable":0},{"_id":"source/images/bock.jpg","path":"images/bock.jpg","modified":1,"renderable":0},{"_id":"source/images/dom.jpg","path":"images/dom.jpg","modified":1,"renderable":0},{"_id":"source/images/front.jpg","path":"images/front.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491016188000},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1514260242000},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1514260242000},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1514260242000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1514260242000},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1514260242000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1514260242000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1514260242000},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1514260242000},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1514260242000},{"_id":"themes/next/_config.yml","hash":"0c332c5c1c563b1310f8912318a03d7843145d81","modified":1517129048000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1514260242000},{"_id":"themes/next/bower.json","hash":"936b9aed1934471bb74cdaacc3fb8031eb01fe23","modified":1514260242000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1514260242000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1514260242000},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1514260242000},{"_id":"themes/next/package.json","hash":"55305ae40690c059cb9140900eb20f9e7f3a7707","modified":1514260242000},{"_id":"source/_posts/Object类的常用方法.md","hash":"077403c98c6fa51d3d890e4987ca35e2e3c0378e","modified":1529057848000},{"_id":"source/_posts/Object类的常用方法（二）.md","hash":"a0e0cade854c8ad771f7328e22d1cf7d665ac552","modified":1529497814000},{"_id":"source/_posts/css.md","hash":"77c6f2ffe4c59054cc1fb0555c734eca32ef2e9c","modified":1514269772000},{"_id":"source/_posts/es6和es7.md","hash":"04e846c648063270ce343aefdb1e1f295067beac","modified":1523878304000},{"_id":"source/_posts/es6箭头函数和普通函数的区别.md","hash":"b95d120dba1af30d1f94f55353a2ac6181e612b2","modified":1526461558000},{"_id":"source/_posts/git默认行为.md","hash":"9bf788d75bf923f3fc8762e4fafa431809606da3","modified":1517126584000},{"_id":"source/_posts/hello-world.md","hash":"98a6008a08e602751ac556c6167e9f5ea427c7f1","modified":1499923904000},{"_id":"source/_posts/http请求和响应.md","hash":"ca76affb8ac60e564b628175daa14d833c6911a7","modified":1517129048000},{"_id":"source/_posts/js数组方法大全.md","hash":"78ed114310cd94e0fde3f11e054add1f2b23685a","modified":1537509530000},{"_id":"source/_posts/js的基本类型和引用类型.md","hash":"eedc3d15454c3425c26b8aa7f1c5c8b97b377e5e","modified":1531719600000},{"_id":"source/_posts/promise的前世今生.md","hash":"a7193dbb5443c3f985e9070a97bc260f4ef8f824","modified":1537509530000},{"_id":"source/_posts/vue单页面分享.md","hash":"a50c2e597e1cfc3aa74b59f58b680bbb489aa86e","modified":1526455920000},{"_id":"source/_posts/webpack4.5+vue.md","hash":"f521a41b276d3db6ea372eb74825bbd52d134228","modified":1523878304000},{"_id":"source/_posts/webtorm目录消失.md","hash":"94d1d2f4c3094505389896ffaadc32d6c7c0796a","modified":1514260242000},{"_id":"source/_posts/圣杯布局和双飞翼布局.md","hash":"6481ab5427577ad52faf888bf4899f57cf5f4862","modified":1529057848000},{"_id":"source/_posts/多终端.md","hash":"2dbe389fbd57e11ea222d0b2b33552f9a1df7400","modified":1514260242000},{"_id":"source/_posts/浅谈 typeof 和 instanceof的区别.md","hash":"0e34b2423db157efc891fe924e59934f65418bdd","modified":1528711338000},{"_id":"source/_posts/继承.md","hash":"18266bdb29739dd150ebcb56ebe527c495e2ed29","modified":1523878304000},{"_id":"source/_posts/跨域.md","hash":"a7193dbb5443c3f985e9070a97bc260f4ef8f824","modified":1537509530000},{"_id":"source/_posts/页面的重绘和重排.md","hash":"38bef96884c5de8d87210df0eee23adc8ebea31d","modified":1523878304000},{"_id":"source/_posts/鱼丁系.md","hash":"7ebd3cb5ef3fc515e64dc71a4f897599043f86ce","modified":1517129048000},{"_id":"source/images/css.gif","hash":"64e7b4e6cf410b496d4e0ae3a2ac320105077676","modified":1536734282000},{"_id":"source/images/html5-layout.jpg","hash":"4bbdda7997b75b279fb138456bd494141c15d66a","modified":1536734282000},{"_id":"source/tags/index.md","hash":"314abe012f8fa15d49e59976de2027e417686907","modified":1517129048000},{"_id":"source/images/bock.jpg","hash":"348f7ce6e51325bba84b176a3ca2f9826e36f0c7","modified":1536744874000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1514260242000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"695d36a14b1fbaf44361dd9363b58ea2fde3e278","modified":1514260242000},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1514260242000},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1514260242000},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1514260242000},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1514260242000},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1514260242000},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1514260242000},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1514260242000},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1514260242000},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1514260242000},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1514260242000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3111ce4cc5f30868b3628f9f805d2aef3b75d1c1","modified":1514260242000},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1514260242000},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1514260242000},{"_id":"themes/next/layout/_layout.swig","hash":"b88585f9e1b7071f6670b20b77b656edd087ccc9","modified":1514260242000},{"_id":"themes/next/layout/archive.swig","hash":"a1d1e91013baaaeb7deaf35c6d3975971ce38e02","modified":1514260242000},{"_id":"themes/next/layout/category.swig","hash":"f315f12651de8065fdad73b003da4335ef177173","modified":1514260242000},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1514260242000},{"_id":"themes/next/layout/page.swig","hash":"22ba721a9688d490fc66f360e5a319288b63b05a","modified":1514260242000},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1514260242000},{"_id":"themes/next/layout/schedule.swig","hash":"8086f1163b10460258ecbbbe48b057b22bb2f02e","modified":1514260242000},{"_id":"themes/next/layout/tag.swig","hash":"cc9878932580c890f8f3e569225e29bb37e25b49","modified":1514260242000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1514260242000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1514260242000},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1514260242000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1514260242000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1514260242000},{"_id":"source/images/dom.jpg","hash":"df9b99e1103f707b7a62751843dabf5e67fdeee3","modified":1536734282000},{"_id":"source/images/front.jpg","hash":"b6f3aa0c912c15ef1c97479fdb0c30de28ff7047","modified":1536734282000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1514260242000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1514260242000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1514260242000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1514260242000},{"_id":"themes/next/layout/_macro/post.swig","hash":"dc3792e703d10daacdb86a9f8d03e846d5b4da83","modified":1514260242000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1514260242000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"0cab451f1df8bba76ee8c81ab345d4de7ad0e15b","modified":1514260242000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1514260242000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a229b569743555215a4f2561997ad496d81e938","modified":1514260242000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"683616f4a80796051e2346d80acf838a589450b0","modified":1514260242000},{"_id":"themes/next/layout/_partials/head.swig","hash":"09b110f77c415c5b71ebd886771a10bc84b95633","modified":1514260242000},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1514260242000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1514260242000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1514260242000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1514260242000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1514260242000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1514260242000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1514260242000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1514260242000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1514260242000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1514260242000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1514260242000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1514260242000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1514260242000},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1514260242000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1514260242000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1514260242000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1514260242000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1514260242000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1514260242000},{"_id":"themes/next/scripts/tags/note.js","hash":"fc4958427ca7bdb47a7d830077f432ed824973e4","modified":1514260242000},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1514260242000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1514260242000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514260242000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1514260242000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1514260242000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1514260242000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1514260242000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1514260242000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1514260242000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1514260242000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514260242000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514260242000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1514260242000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1514260242000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514260242000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514260242000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1514260242000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1514260242000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1514260242000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1514260242000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1514260242000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1514260242000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1514260242000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1514260242000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1514260242000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"be2aaeb8f05979e2ba501248480d5294256d61f2","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1514260242000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1514260242000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1514260242000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1514260242000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1514260242000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1514260242000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1514260242000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1514260242000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1514260242000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1514260242000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"d1dfb6348ef7fafe140b170186340d6d5733bdf1","modified":1514260242000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1514260242000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1514260242000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dacede1cc110c762e7a5468dc0e34ae1a962d5aa","modified":1514260242000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1514260242000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1514260242000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ec035e20d1f26bf553a79877180ba312bea885c","modified":1514260242000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1514260242000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1514260242000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1514260242000},{"_id":"themes/next/source/js/src/motion.js","hash":"dda8c76fce91d7f140c06de2583ba806810f12c2","modified":1514260242000},{"_id":"themes/next/source/js/src/post-details.js","hash":"bfaf52b69aad96566aa21b785973441a2555b4ba","modified":1514260242000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1514260242000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1514260242000},{"_id":"themes/next/source/js/src/utils.js","hash":"e7465a22b536ed15006a5f5556d9a4e633f6bd71","modified":1514260242000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514260242000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"82fee688910efc644d3d1c3305c6ae28ba3f38f9","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1500271188000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514260242000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1500271188000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1514260242000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1514260242000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1514260242000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1514260242000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1514260242000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1514260242000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1514260242000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1514260242000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1514260242000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1514260242000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1514260242000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1514260242000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1514260242000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514260242000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1514260242000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1514260242000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1514260242000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1514260242000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1514260242000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1514260242000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1514260242000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d68bdfcdb9d9e0bf60ed9a2df88e0b55cbfcc1e6","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1514260242000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1514260242000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4998bedff9c84a09a294b8ef36ede2e3644d3528","modified":1514260242000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1514260242000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1514260242000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1514260242000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1514260242000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"95518d298d3c5c271faec2e4977df9e5dedd5d84","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1514260242000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1514260242000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1514260242000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1514260242000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"524cfca7b6ab135d81ea723d8de06fdf0dbe7e56","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514260242000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"658accf8e196721f295003da66941e6d1f7b81b0","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2cb09973d29a8e34e2a3425ac6e0938296970d8e","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"268c9704481fdb0b4d1e646196386143990fe235","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bc08cfb2ef2ff44ba3fc7dffdb2deb01a9d17d15","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e00d9a0bdf35ffc0a7fa387fa294b953c2d28fc","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74019008ba973ab30f0f4a6b3c2cd33c66d3a4b4","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1514260242000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"37e406ec42b7a53c72395bdbaa434270019e7179","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1514260242000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514260242000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1514260242000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514260242000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1514260242000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1514260242000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1514260242000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Object类的常用方法 （一）","_content":"### 背景：\n\n\n\n> js中对Object的一些操作\n\n> 对象是值： 成对的名称（字符串）和值（任何值），其中名称通过冒号与值分隔；\t\n\n#### 一 、创建对象的方法：\n\n1. 字面量形式：\n\n\tvar obj = {\n\t\ta:1，\n\t\tb:2\n\t}; \n\n2. 对象实例\n\n\tvar obj = new Object();\n3. 构造函数形式\n\n\t\tfunction employee(name,job,born) {\n\t\t    this.name=name;\n\t\t    this.job=job;\n\t\t    this.born=born;\n\t\t}\n\n\t\tvar bill=new employee(\"Bill Gates\",\"Engineer\",1985);\n \n\t\t// employee {name: \"Bill Gates\", job: \"Engineer\", born: 1985} \n\n\t\n4. es6 class模式\n\n\t//定义类\n\n\t\tclass point = {\n\t\t\tconstructor(x,y){\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\t\n\t\t\t};\n\t\n\t\t\t//定义方法\n\t\t\ttostring(){\n\t\t\t\treturn '('+this.x+','+this.y+')';\n\t\t\t}\n\t\n\t\t\tmultiplication(){\n\t\t\t\treturn this.x*this.y\n\t\t\t}\n\t\n\t\t\ttest(){\n\t\t\t\treturn '1234567890'\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(point.name)\n\t\t//Point （name属性总是返回紧跟在class关键字后面的类名。）\n        \n        // 实例化并调用（实例化和调用方法同es5相同）\n        var x = new Point(5, 6)\n        console.log(x.toString(), '相乘结果：' + x.multiplication(), x.test())\n        // (5, 6) 相乘结果：30 1231354654\n       \n        // 快速添加方法到原型上 （如下图，直接可添加到原型）\n        Object.assign(Point.prototype, {\n            dosomething() { },\n            toValue() { }\n        });\n        console.log(Point.prototype)\n\t\n#### 二、Object的常用方法\n\n##### 1、 Object.assign：  浅拷贝复制\n\n> Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 Object.assign(target, ...sources)\n\n参数:\n\ntarget:目标对象;sources:源对象;返回值:目标对象\n\n1. 复制一个对象，并不会影响原对象\n\n\t\tvar obj = {a:1};\n\t\tvar copy = Object.assign({},obj);\n\t\tconsole.log(copy) // {a:1}\n\n2. 合并对象\n\t\t\n\t\t//object.assign(obj, obj2)  obj2是源对象，obj 是目标对象，返回目标对象\n\t \n\t\tvar obj = { a: 1 };\n\t\tvar obj2={b:2};\n\t\t\n\t\tconsole.log(Object.assign(obj,obj2)===obj);  //true，返回目标对象\n\t\tconsole.log(obj);       //{a:1,b:2} obj的值已被更改\n\n3. 如果目标对象和源对象有相同的属性，则会被覆盖，后面的对象会覆盖掉前面的属性\n\t\n\t \n\t\tvar obj = { a: 1 };\n\t\tvar obj1 = {a:2,b:5};\n\t\tvar obj2={b:2};\n\t\t\n\t\tObject.assign(obj,obj1,obj2);  //{a:2,b:2}\n\n4. 当assign只有一个对象时，则直接返回这个对象，不做任何操作\n\n5. Object.assign是浅拷贝，copy的是一个对象的引用\n\n\t\tvar obj1 = { a: 0 , b: { c: 0}};\n\t\tvar obj2 = Object.assign({}, obj1);\n\t\tobj1.b.c=5;\n\t\n\t\tconsole.log(obj2)       //{a:0,b:{c:5}};\n\n\t当我们在改变obj1的值时，并没有想改变obj2，但obj2的值也发生了改变，这违背了我们的想法\n\n6.  深拷贝\n\t\n\t\tvar obj = { a: 0 , b: { c: 0}};\n\t\tvar obj2 = JSON.parse(JSON.stringify(obj));\n\t\tobj.a = 4;\n\t\tobj.b.c = 4;\n\t\tconsole.log(obj2)   //{ a: 0 , b: { c: 0}}\n\t\t\n\n##### 2、 Object.is()\n\n判断两个值是否是同一个值 \n\n参数:  Object.is(value1,value2)\n\t\nvalue1:需要比较的第一个值。 value2:需要比较的第二个值。 返回值:表示两个参数是否相同的Boolean\n\n\n\t\tObject.is('haorooms', 'haorooms');     // true\n\t\tObject.is(window, window);   // true\n\t\t\n\t\tObject.is('foo', 'bar');     // false\n\t\tObject.is([], []);           // false\n\t\t\n\t\tvar test = { a: 1 };\n\t\tObject.is(test, test);       // true\n\t\t\n\t\tObject.is(null, null);       // true\n\t\t\n\t\t// 特例\n\t\tObject.is(0, -0);            // false\n\t\tObject.is(-0, -0);           // true\n\t\tObject.is(NaN, 0/0);         // true\t\n\n##### 3、 Object.keys()\n\n> 这个方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。\n\n\t1）数组对象\n\t\tvar arr=[1,2,3];            \n\t\tObject.keys(arr)         //  [\"0\", \"1\", \"2”]\n\n\t2） object对象\n\t\tvar obj = { foo: \"bar\", baz: 42 };\n\t\tObject.keys(obj)        //  [\"foo\", \"baz”]\n\n\t(3)类数组，对象\n\n\t\tvar obj = { 0 : \"a\", 1 : \"b\", 2 : \"c”};\n\t\tObject.keys(obj)       // [\"0\", \"1\", \"2\"] \n\n##### 4、 Object.values()\n\n\n> 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for..in循环相同，返回的对象的value值，与Object.key()相反\n\n\tvar obj = {a:1,b:2,c:3};\n\tconsole.log(Object.values(obj))   //  [1, 2, 3]\n\n\tvar obj ={0:'a',1:'b',2:'c'};\n\tconsole.log(Object.values(obj)).       //  a,b,c\n\n\tvar obj={100:'a',10:'b',1:'1'};\n\tconsole.log(Object.values(obj)).   // [\"1\", \"b\", \"a\"]\n\n##### 待更新：\n##### 5、 Object.entries:\t\n\n##### 6、 Object.create:\t\n\t\t\n##### 7、 Object.defineProperties\n\n##### 8、Object.defineProperty\n\n##### 9、Object.hasOwnProperty\n\n\n其他不常用方法：\n\n\t1、Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\t\n\t2、Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。\n\t\n\t3、Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n\t\n\t4、Object.isSealed() 方法判断一个对象是否是密封的（sealed）。\n\t\n\t5、Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。","source":"_posts/Object类的常用方法.md","raw":"---\ntitle: Object类的常用方法 （一）\n---\n### 背景：\n\n\n\n> js中对Object的一些操作\n\n> 对象是值： 成对的名称（字符串）和值（任何值），其中名称通过冒号与值分隔；\t\n\n#### 一 、创建对象的方法：\n\n1. 字面量形式：\n\n\tvar obj = {\n\t\ta:1，\n\t\tb:2\n\t}; \n\n2. 对象实例\n\n\tvar obj = new Object();\n3. 构造函数形式\n\n\t\tfunction employee(name,job,born) {\n\t\t    this.name=name;\n\t\t    this.job=job;\n\t\t    this.born=born;\n\t\t}\n\n\t\tvar bill=new employee(\"Bill Gates\",\"Engineer\",1985);\n \n\t\t// employee {name: \"Bill Gates\", job: \"Engineer\", born: 1985} \n\n\t\n4. es6 class模式\n\n\t//定义类\n\n\t\tclass point = {\n\t\t\tconstructor(x,y){\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\t\n\t\t\t};\n\t\n\t\t\t//定义方法\n\t\t\ttostring(){\n\t\t\t\treturn '('+this.x+','+this.y+')';\n\t\t\t}\n\t\n\t\t\tmultiplication(){\n\t\t\t\treturn this.x*this.y\n\t\t\t}\n\t\n\t\t\ttest(){\n\t\t\t\treturn '1234567890'\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(point.name)\n\t\t//Point （name属性总是返回紧跟在class关键字后面的类名。）\n        \n        // 实例化并调用（实例化和调用方法同es5相同）\n        var x = new Point(5, 6)\n        console.log(x.toString(), '相乘结果：' + x.multiplication(), x.test())\n        // (5, 6) 相乘结果：30 1231354654\n       \n        // 快速添加方法到原型上 （如下图，直接可添加到原型）\n        Object.assign(Point.prototype, {\n            dosomething() { },\n            toValue() { }\n        });\n        console.log(Point.prototype)\n\t\n#### 二、Object的常用方法\n\n##### 1、 Object.assign：  浅拷贝复制\n\n> Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 Object.assign(target, ...sources)\n\n参数:\n\ntarget:目标对象;sources:源对象;返回值:目标对象\n\n1. 复制一个对象，并不会影响原对象\n\n\t\tvar obj = {a:1};\n\t\tvar copy = Object.assign({},obj);\n\t\tconsole.log(copy) // {a:1}\n\n2. 合并对象\n\t\t\n\t\t//object.assign(obj, obj2)  obj2是源对象，obj 是目标对象，返回目标对象\n\t \n\t\tvar obj = { a: 1 };\n\t\tvar obj2={b:2};\n\t\t\n\t\tconsole.log(Object.assign(obj,obj2)===obj);  //true，返回目标对象\n\t\tconsole.log(obj);       //{a:1,b:2} obj的值已被更改\n\n3. 如果目标对象和源对象有相同的属性，则会被覆盖，后面的对象会覆盖掉前面的属性\n\t\n\t \n\t\tvar obj = { a: 1 };\n\t\tvar obj1 = {a:2,b:5};\n\t\tvar obj2={b:2};\n\t\t\n\t\tObject.assign(obj,obj1,obj2);  //{a:2,b:2}\n\n4. 当assign只有一个对象时，则直接返回这个对象，不做任何操作\n\n5. Object.assign是浅拷贝，copy的是一个对象的引用\n\n\t\tvar obj1 = { a: 0 , b: { c: 0}};\n\t\tvar obj2 = Object.assign({}, obj1);\n\t\tobj1.b.c=5;\n\t\n\t\tconsole.log(obj2)       //{a:0,b:{c:5}};\n\n\t当我们在改变obj1的值时，并没有想改变obj2，但obj2的值也发生了改变，这违背了我们的想法\n\n6.  深拷贝\n\t\n\t\tvar obj = { a: 0 , b: { c: 0}};\n\t\tvar obj2 = JSON.parse(JSON.stringify(obj));\n\t\tobj.a = 4;\n\t\tobj.b.c = 4;\n\t\tconsole.log(obj2)   //{ a: 0 , b: { c: 0}}\n\t\t\n\n##### 2、 Object.is()\n\n判断两个值是否是同一个值 \n\n参数:  Object.is(value1,value2)\n\t\nvalue1:需要比较的第一个值。 value2:需要比较的第二个值。 返回值:表示两个参数是否相同的Boolean\n\n\n\t\tObject.is('haorooms', 'haorooms');     // true\n\t\tObject.is(window, window);   // true\n\t\t\n\t\tObject.is('foo', 'bar');     // false\n\t\tObject.is([], []);           // false\n\t\t\n\t\tvar test = { a: 1 };\n\t\tObject.is(test, test);       // true\n\t\t\n\t\tObject.is(null, null);       // true\n\t\t\n\t\t// 特例\n\t\tObject.is(0, -0);            // false\n\t\tObject.is(-0, -0);           // true\n\t\tObject.is(NaN, 0/0);         // true\t\n\n##### 3、 Object.keys()\n\n> 这个方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。\n\n\t1）数组对象\n\t\tvar arr=[1,2,3];            \n\t\tObject.keys(arr)         //  [\"0\", \"1\", \"2”]\n\n\t2） object对象\n\t\tvar obj = { foo: \"bar\", baz: 42 };\n\t\tObject.keys(obj)        //  [\"foo\", \"baz”]\n\n\t(3)类数组，对象\n\n\t\tvar obj = { 0 : \"a\", 1 : \"b\", 2 : \"c”};\n\t\tObject.keys(obj)       // [\"0\", \"1\", \"2\"] \n\n##### 4、 Object.values()\n\n\n> 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for..in循环相同，返回的对象的value值，与Object.key()相反\n\n\tvar obj = {a:1,b:2,c:3};\n\tconsole.log(Object.values(obj))   //  [1, 2, 3]\n\n\tvar obj ={0:'a',1:'b',2:'c'};\n\tconsole.log(Object.values(obj)).       //  a,b,c\n\n\tvar obj={100:'a',10:'b',1:'1'};\n\tconsole.log(Object.values(obj)).   // [\"1\", \"b\", \"a\"]\n\n##### 待更新：\n##### 5、 Object.entries:\t\n\n##### 6、 Object.create:\t\n\t\t\n##### 7、 Object.defineProperties\n\n##### 8、Object.defineProperty\n\n##### 9、Object.hasOwnProperty\n\n\n其他不常用方法：\n\n\t1、Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\t\n\t2、Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。\n\t\n\t3、Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n\t\n\t4、Object.isSealed() 方法判断一个对象是否是密封的（sealed）。\n\t\n\t5、Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。","slug":"Object类的常用方法","published":1,"date":"2018-06-15T10:17:28.000Z","updated":"2018-06-15T10:17:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmport0000g4s6lhu9yrim","content":"<h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><blockquote>\n<p>js中对Object的一些操作</p>\n</blockquote>\n<blockquote>\n<p>对象是值： 成对的名称（字符串）和值（任何值），其中名称通过冒号与值分隔；    </p>\n</blockquote>\n<h4 id=\"一-、创建对象的方法：\"><a href=\"#一-、创建对象的方法：\" class=\"headerlink\" title=\"一 、创建对象的方法：\"></a>一 、创建对象的方法：</h4><ol>\n<li><p>字面量形式：</p>\n<p> var obj = {</p>\n<pre><code>a:1，\nb:2\n</code></pre><p> }; </p>\n</li>\n<li><p>对象实例</p>\n<p> var obj = new Object();</p>\n</li>\n<li><p>构造函数形式</p>\n<pre><code>function employee(name,job,born) {\n    this.name=name;\n    this.job=job;\n    this.born=born;\n}\n\nvar bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);\n\n// employee {name: &quot;Bill Gates&quot;, job: &quot;Engineer&quot;, born: 1985} \n</code></pre></li>\n</ol>\n<ol start=\"4\">\n<li><p>es6 class模式</p>\n<p> //定义类</p>\n<pre><code>class point = {\n    constructor(x,y){\n        this.x = x;\n        this.y = y;    \n    };\n\n    //定义方法\n    tostring(){\n        return &apos;(&apos;+this.x+&apos;,&apos;+this.y+&apos;)&apos;;\n    }\n\n    multiplication(){\n        return this.x*this.y\n    }\n\n    test(){\n        return &apos;1234567890&apos;\n    }\n}\n\nconsole.log(point.name)\n//Point （name属性总是返回紧跟在class关键字后面的类名。）\n\n// 实例化并调用（实例化和调用方法同es5相同）\nvar x = new Point(5, 6)\nconsole.log(x.toString(), &apos;相乘结果：&apos; + x.multiplication(), x.test())\n// (5, 6) 相乘结果：30 1231354654\n\n// 快速添加方法到原型上 （如下图，直接可添加到原型）\nObject.assign(Point.prototype, {\n    dosomething() { },\n    toValue() { }\n});\nconsole.log(Point.prototype)\n</code></pre></li>\n</ol>\n<h4 id=\"二、Object的常用方法\"><a href=\"#二、Object的常用方法\" class=\"headerlink\" title=\"二、Object的常用方法\"></a>二、Object的常用方法</h4><h5 id=\"1、-Object-assign：-浅拷贝复制\"><a href=\"#1、-Object-assign：-浅拷贝复制\" class=\"headerlink\" title=\"1、 Object.assign：  浅拷贝复制\"></a>1、 Object.assign：  浅拷贝复制</h5><blockquote>\n<p>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 Object.assign(target, …sources)</p>\n</blockquote>\n<p>参数:</p>\n<p>target:目标对象;sources:源对象;返回值:目标对象</p>\n<ol>\n<li><p>复制一个对象，并不会影响原对象</p>\n<pre><code>var obj = {a:1};\nvar copy = Object.assign({},obj);\nconsole.log(copy) // {a:1}\n</code></pre></li>\n<li><p>合并对象</p>\n<pre><code>//object.assign(obj, obj2)  obj2是源对象，obj 是目标对象，返回目标对象\n\nvar obj = { a: 1 };\nvar obj2={b:2};\n\nconsole.log(Object.assign(obj,obj2)===obj);  //true，返回目标对象\nconsole.log(obj);       //{a:1,b:2} obj的值已被更改\n</code></pre></li>\n<li><p>如果目标对象和源对象有相同的属性，则会被覆盖，后面的对象会覆盖掉前面的属性</p>\n</li>\n</ol>\n<pre><code>var obj = { a: 1 };\nvar obj1 = {a:2,b:5};\nvar obj2={b:2};\n\nObject.assign(obj,obj1,obj2);  //{a:2,b:2}\n</code></pre><ol start=\"4\">\n<li><p>当assign只有一个对象时，则直接返回这个对象，不做任何操作</p>\n</li>\n<li><p>Object.assign是浅拷贝，copy的是一个对象的引用</p>\n<pre><code>var obj1 = { a: 0 , b: { c: 0}};\nvar obj2 = Object.assign({}, obj1);\nobj1.b.c=5;\n\nconsole.log(obj2)       //{a:0,b:{c:5}};\n</code></pre><p> 当我们在改变obj1的值时，并没有想改变obj2，但obj2的值也发生了改变，这违背了我们的想法</p>\n</li>\n<li><p>深拷贝</p>\n<pre><code>var obj = { a: 0 , b: { c: 0}};\nvar obj2 = JSON.parse(JSON.stringify(obj));\nobj.a = 4;\nobj.b.c = 4;\nconsole.log(obj2)   //{ a: 0 , b: { c: 0}}\n</code></pre></li>\n</ol>\n<h5 id=\"2、-Object-is\"><a href=\"#2、-Object-is\" class=\"headerlink\" title=\"2、 Object.is()\"></a>2、 Object.is()</h5><p>判断两个值是否是同一个值 </p>\n<p>参数:  Object.is(value1,value2)</p>\n<p>value1:需要比较的第一个值。 value2:需要比较的第二个值。 返回值:表示两个参数是否相同的Boolean</p>\n<pre><code>Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;);     // true\nObject.is(window, window);   // true\n\nObject.is(&apos;foo&apos;, &apos;bar&apos;);     // false\nObject.is([], []);           // false\n\nvar test = { a: 1 };\nObject.is(test, test);       // true\n\nObject.is(null, null);       // true\n\n// 特例\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true    \n</code></pre><h5 id=\"3、-Object-keys\"><a href=\"#3、-Object-keys\" class=\"headerlink\" title=\"3、 Object.keys()\"></a>3、 Object.keys()</h5><blockquote>\n<p>这个方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p>\n</blockquote>\n<pre><code>1）数组对象\n    var arr=[1,2,3];            \n    Object.keys(arr)         //  [&quot;0&quot;, &quot;1&quot;, &quot;2”]\n\n2） object对象\n    var obj = { foo: &quot;bar&quot;, baz: 42 };\n    Object.keys(obj)        //  [&quot;foo&quot;, &quot;baz”]\n\n(3)类数组，对象\n\n    var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c”};\n    Object.keys(obj)       // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] \n</code></pre><h5 id=\"4、-Object-values\"><a href=\"#4、-Object-values\" class=\"headerlink\" title=\"4、 Object.values()\"></a>4、 Object.values()</h5><blockquote>\n<p>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for..in循环相同，返回的对象的value值，与Object.key()相反</p>\n</blockquote>\n<pre><code>var obj = {a:1,b:2,c:3};\nconsole.log(Object.values(obj))   //  [1, 2, 3]\n\nvar obj ={0:&apos;a&apos;,1:&apos;b&apos;,2:&apos;c&apos;};\nconsole.log(Object.values(obj)).       //  a,b,c\n\nvar obj={100:&apos;a&apos;,10:&apos;b&apos;,1:&apos;1&apos;};\nconsole.log(Object.values(obj)).   // [&quot;1&quot;, &quot;b&quot;, &quot;a&quot;]\n</code></pre><h5 id=\"待更新：\"><a href=\"#待更新：\" class=\"headerlink\" title=\"待更新：\"></a>待更新：</h5><h5 id=\"5、-Object-entries\"><a href=\"#5、-Object-entries\" class=\"headerlink\" title=\"5、 Object.entries:\"></a>5、 Object.entries:</h5><h5 id=\"6、-Object-create\"><a href=\"#6、-Object-create\" class=\"headerlink\" title=\"6、 Object.create:\"></a>6、 Object.create:</h5><h5 id=\"7、-Object-defineProperties\"><a href=\"#7、-Object-defineProperties\" class=\"headerlink\" title=\"7、 Object.defineProperties\"></a>7、 Object.defineProperties</h5><h5 id=\"8、Object-defineProperty\"><a href=\"#8、Object-defineProperty\" class=\"headerlink\" title=\"8、Object.defineProperty\"></a>8、Object.defineProperty</h5><h5 id=\"9、Object-hasOwnProperty\"><a href=\"#9、Object-hasOwnProperty\" class=\"headerlink\" title=\"9、Object.hasOwnProperty\"></a>9、Object.hasOwnProperty</h5><p>其他不常用方法：</p>\n<pre><code>1、Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\n2、Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。\n\n3、Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n\n4、Object.isSealed() 方法判断一个对象是否是密封的（sealed）。\n\n5、Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><blockquote>\n<p>js中对Object的一些操作</p>\n</blockquote>\n<blockquote>\n<p>对象是值： 成对的名称（字符串）和值（任何值），其中名称通过冒号与值分隔；    </p>\n</blockquote>\n<h4 id=\"一-、创建对象的方法：\"><a href=\"#一-、创建对象的方法：\" class=\"headerlink\" title=\"一 、创建对象的方法：\"></a>一 、创建对象的方法：</h4><ol>\n<li><p>字面量形式：</p>\n<p> var obj = {</p>\n<pre><code>a:1，\nb:2\n</code></pre><p> }; </p>\n</li>\n<li><p>对象实例</p>\n<p> var obj = new Object();</p>\n</li>\n<li><p>构造函数形式</p>\n<pre><code>function employee(name,job,born) {\n    this.name=name;\n    this.job=job;\n    this.born=born;\n}\n\nvar bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);\n\n// employee {name: &quot;Bill Gates&quot;, job: &quot;Engineer&quot;, born: 1985} \n</code></pre></li>\n</ol>\n<ol start=\"4\">\n<li><p>es6 class模式</p>\n<p> //定义类</p>\n<pre><code>class point = {\n    constructor(x,y){\n        this.x = x;\n        this.y = y;    \n    };\n\n    //定义方法\n    tostring(){\n        return &apos;(&apos;+this.x+&apos;,&apos;+this.y+&apos;)&apos;;\n    }\n\n    multiplication(){\n        return this.x*this.y\n    }\n\n    test(){\n        return &apos;1234567890&apos;\n    }\n}\n\nconsole.log(point.name)\n//Point （name属性总是返回紧跟在class关键字后面的类名。）\n\n// 实例化并调用（实例化和调用方法同es5相同）\nvar x = new Point(5, 6)\nconsole.log(x.toString(), &apos;相乘结果：&apos; + x.multiplication(), x.test())\n// (5, 6) 相乘结果：30 1231354654\n\n// 快速添加方法到原型上 （如下图，直接可添加到原型）\nObject.assign(Point.prototype, {\n    dosomething() { },\n    toValue() { }\n});\nconsole.log(Point.prototype)\n</code></pre></li>\n</ol>\n<h4 id=\"二、Object的常用方法\"><a href=\"#二、Object的常用方法\" class=\"headerlink\" title=\"二、Object的常用方法\"></a>二、Object的常用方法</h4><h5 id=\"1、-Object-assign：-浅拷贝复制\"><a href=\"#1、-Object-assign：-浅拷贝复制\" class=\"headerlink\" title=\"1、 Object.assign：  浅拷贝复制\"></a>1、 Object.assign：  浅拷贝复制</h5><blockquote>\n<p>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 Object.assign(target, …sources)</p>\n</blockquote>\n<p>参数:</p>\n<p>target:目标对象;sources:源对象;返回值:目标对象</p>\n<ol>\n<li><p>复制一个对象，并不会影响原对象</p>\n<pre><code>var obj = {a:1};\nvar copy = Object.assign({},obj);\nconsole.log(copy) // {a:1}\n</code></pre></li>\n<li><p>合并对象</p>\n<pre><code>//object.assign(obj, obj2)  obj2是源对象，obj 是目标对象，返回目标对象\n\nvar obj = { a: 1 };\nvar obj2={b:2};\n\nconsole.log(Object.assign(obj,obj2)===obj);  //true，返回目标对象\nconsole.log(obj);       //{a:1,b:2} obj的值已被更改\n</code></pre></li>\n<li><p>如果目标对象和源对象有相同的属性，则会被覆盖，后面的对象会覆盖掉前面的属性</p>\n</li>\n</ol>\n<pre><code>var obj = { a: 1 };\nvar obj1 = {a:2,b:5};\nvar obj2={b:2};\n\nObject.assign(obj,obj1,obj2);  //{a:2,b:2}\n</code></pre><ol start=\"4\">\n<li><p>当assign只有一个对象时，则直接返回这个对象，不做任何操作</p>\n</li>\n<li><p>Object.assign是浅拷贝，copy的是一个对象的引用</p>\n<pre><code>var obj1 = { a: 0 , b: { c: 0}};\nvar obj2 = Object.assign({}, obj1);\nobj1.b.c=5;\n\nconsole.log(obj2)       //{a:0,b:{c:5}};\n</code></pre><p> 当我们在改变obj1的值时，并没有想改变obj2，但obj2的值也发生了改变，这违背了我们的想法</p>\n</li>\n<li><p>深拷贝</p>\n<pre><code>var obj = { a: 0 , b: { c: 0}};\nvar obj2 = JSON.parse(JSON.stringify(obj));\nobj.a = 4;\nobj.b.c = 4;\nconsole.log(obj2)   //{ a: 0 , b: { c: 0}}\n</code></pre></li>\n</ol>\n<h5 id=\"2、-Object-is\"><a href=\"#2、-Object-is\" class=\"headerlink\" title=\"2、 Object.is()\"></a>2、 Object.is()</h5><p>判断两个值是否是同一个值 </p>\n<p>参数:  Object.is(value1,value2)</p>\n<p>value1:需要比较的第一个值。 value2:需要比较的第二个值。 返回值:表示两个参数是否相同的Boolean</p>\n<pre><code>Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;);     // true\nObject.is(window, window);   // true\n\nObject.is(&apos;foo&apos;, &apos;bar&apos;);     // false\nObject.is([], []);           // false\n\nvar test = { a: 1 };\nObject.is(test, test);       // true\n\nObject.is(null, null);       // true\n\n// 特例\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true    \n</code></pre><h5 id=\"3、-Object-keys\"><a href=\"#3、-Object-keys\" class=\"headerlink\" title=\"3、 Object.keys()\"></a>3、 Object.keys()</h5><blockquote>\n<p>这个方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p>\n</blockquote>\n<pre><code>1）数组对象\n    var arr=[1,2,3];            \n    Object.keys(arr)         //  [&quot;0&quot;, &quot;1&quot;, &quot;2”]\n\n2） object对象\n    var obj = { foo: &quot;bar&quot;, baz: 42 };\n    Object.keys(obj)        //  [&quot;foo&quot;, &quot;baz”]\n\n(3)类数组，对象\n\n    var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c”};\n    Object.keys(obj)       // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] \n</code></pre><h5 id=\"4、-Object-values\"><a href=\"#4、-Object-values\" class=\"headerlink\" title=\"4、 Object.values()\"></a>4、 Object.values()</h5><blockquote>\n<p>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for..in循环相同，返回的对象的value值，与Object.key()相反</p>\n</blockquote>\n<pre><code>var obj = {a:1,b:2,c:3};\nconsole.log(Object.values(obj))   //  [1, 2, 3]\n\nvar obj ={0:&apos;a&apos;,1:&apos;b&apos;,2:&apos;c&apos;};\nconsole.log(Object.values(obj)).       //  a,b,c\n\nvar obj={100:&apos;a&apos;,10:&apos;b&apos;,1:&apos;1&apos;};\nconsole.log(Object.values(obj)).   // [&quot;1&quot;, &quot;b&quot;, &quot;a&quot;]\n</code></pre><h5 id=\"待更新：\"><a href=\"#待更新：\" class=\"headerlink\" title=\"待更新：\"></a>待更新：</h5><h5 id=\"5、-Object-entries\"><a href=\"#5、-Object-entries\" class=\"headerlink\" title=\"5、 Object.entries:\"></a>5、 Object.entries:</h5><h5 id=\"6、-Object-create\"><a href=\"#6、-Object-create\" class=\"headerlink\" title=\"6、 Object.create:\"></a>6、 Object.create:</h5><h5 id=\"7、-Object-defineProperties\"><a href=\"#7、-Object-defineProperties\" class=\"headerlink\" title=\"7、 Object.defineProperties\"></a>7、 Object.defineProperties</h5><h5 id=\"8、Object-defineProperty\"><a href=\"#8、Object-defineProperty\" class=\"headerlink\" title=\"8、Object.defineProperty\"></a>8、Object.defineProperty</h5><h5 id=\"9、Object-hasOwnProperty\"><a href=\"#9、Object-hasOwnProperty\" class=\"headerlink\" title=\"9、Object.hasOwnProperty\"></a>9、Object.hasOwnProperty</h5><p>其他不常用方法：</p>\n<pre><code>1、Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\n2、Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。\n\n3、Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n\n4、Object.isSealed() 方法判断一个对象是否是密封的（sealed）。\n\n5、Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。\n</code></pre>"},{"title":"Object类的常用方法 （二）","_content":"-----------\n> 续上文Object类的常用方法（一）\n\n> 上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()\n本篇文章会有点枯燥捏！\n\n下面就按顺序排了\n##### 5、 Object.entries:\t\n\n> `Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。\n\n    Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。\n\n    参数： Object.entries(obj), 其中 obj 可以返回其可枚举属性的键值对的对象。\n\n    返回值： 给定对象自身可枚举属性的键值对数组。\n\n举个栗子：\n\n\tconst obj = { foo: 'bar', baz: 42 };\n\tconsole.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\t\n\t// array like object\n\tconst obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]\n\t\n\t// array like object with random key ordering\n\tconst anObj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]\n\t\n\t// getFoo is property which isn't enumerable\n\tconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });\n\tmyObj.foo = 'bar';\n\tconsole.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]\n\t\n\t// non-object argument will be coerced to an object\n\tconsole.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]\n\t\n\t// iterate through key-value gracefully\n\tconst obj = { a: 5, b: 7, c: 9 };\n\tfor (const [key, value] of Object.entries(obj)) {\n\t  console.log(`${key} ${value}`); // \"a 5\", \"b 7\", \"c 9\"\n\t}\n\t\n\t// Or, using array extras\n\tObject.entries(obj).forEach(([key, value]) => {\n\tconsole.log(`${key} ${value}`); // \"a 5\", \"b 7\", \"c 9\"\n\t});\n\n\n##### 6、 Object.create:\t\n\t\t\n> ` Object.create()` 方法会使用指定的原型对象及其属性去创建一个新的对象\n> \n> Object.create(proto[, propertiesObject])\n\n> 其中参数proto为一个对象，作为新创建对象的原型\n> \n> propertiesObject: 对象，可选参数，为新创建的对象指定属性对象。\n\n** 注意，使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。**\n\n来看一个简单的例子：\n\n\t// 基类\n\tfunction Site() {\n\t  this.name = 'Site';\n\t  this.domain = 'domain';\n\t}\n\n\tSite.prototype.create = function(name, domain) {\n\t  this.name = name;\n\t  this.domain = domain;\n\t};\n\t\n\t// 子类\n\tfunction Itbilu() {\n\t  Site.call(this); //调用基类的构造函数\n\t}\n\t\n\t// 继承父类\n\tItbilu.prototype = Object.create(Site.prototype);\n\t\n\t// 创建类实例\n\tvar itbilu = new Itbilu();\n\t\n\titbilu instanceof Site;  // true\n\ttbilu instanceof Itbilu;  // true\n\t\n\titbilu.create('IT笔录', 'itbilu.com');\n\titbilu.name;    // 'IT笔录'\n\titbilu.domain;  // 'itbilu.com'\n\n使用 ` Object.create()` 的 propertyObject参数\n\n\tvar o;\n\t\n\t// 创建一个原型为null的空对象\n\to = Object.create(null);\n\t\n\to = {};\n\t// 以字面量方式创建的空对象就相当于:\n\to = Object.create(Object.prototype);\n\t\n\to = Object.create(Object.prototype, {\n\t  // foo会成为所创建对象的数据属性\n\t  foo: { \n\t    writable:true,\n\t    configurable:true,\n\t    value: \"hello\" \n\t  },\n\t  // bar会成为所创建对象的访问器属性\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10 },\n\t    set: function(value) {\n\t      console.log(\"Setting `o.bar` to\", value);\n\t    }\n\t  }\n\t});\n\t\n##### 7、Object.defineProperty\n\t\n\t语法： Object.defineProperty(obj, prop, descriptor)\n\t参数： \n\t\tobj：必需。目标对象 \n\t\tprop：必需。需定义或修改的属性的名字\n\t\tdescriptor：必需。目标属性所拥有的特性\n\t返回值： 传入函数的对象。即第一个参数obj\n\n针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历\n\n给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。\n\n数据描述：\n当修改或者定义对象的某个属性的时候，给这个属性添加一些特性：\n\t\n    var obj = {\n        test:\"hello\"\n    }\n    //对象已有的属性添加特性描述\n    Object.defineProperty(obj,\"test\",{\n        configurable:true | false,\n        enumerable:true | false,\n        value:任意类型的值,\n        writable:true | false\n    });\n    //对象新添加的属性的特性描述\n    Object.defineProperty(obj,\"newKey\",{\n        configurable:true | false,\n        enumerable:true | false,\n        value:任意类型的值,\n        writable:true | false\n    });\n\n数据描述中的属性都是可选的。看一下每个设置的作用。\n\n1) value： 属性对应的值,可以使任意类型的值，默认为undefined\n\n\tvar obj = {};\n\t//第一种情况，不设置value属性。\n\tObject.defineProperty(obj,\"newKey\",{})\n\tconsole.log(obj.newKey);   //undefined\t\n\t//第二种 设置value属性\n\n\tObject.defineProperty(obj,\"newKey\",{\n\t\tvalue： 'hello'\n\t})\n\tconsole.log(obj.newKey);   //hello\t\n\n2) writable \n    属性的值是否可以被重写。设置为true可以被重写，设置为false,不可被重写。 默认为false\n\n\tvar obj = {}\n\t//第一种情况：writable设置为false，不能重写。\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:false\n\t});\n\t//更改newKey的值\n\tobj.newKey = \"change value\";\n\tconsole.log( obj.newKey );  //hello\n\n\t//第二种情况：writable设置为true，可以重写\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:true\n\t});\n\t//更改newKey的值\n\tobj.newKey = \"change value\";\n\tconsole.log( obj.newKey );  //change value\n\n3)  enumerable\n此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。\n\n\tvar obj = {}\n\t//第一种情况：enumerable设置为false，不能被枚举。\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:false,\n\t    enumerable:false\n\t});\n\t\n\t//枚举对象的属性\n\tfor( var attr in obj ){\n\t    console.log( attr );  \n\t}\n\t//第二种情况：enumerable设置为true，可以被枚举。\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:false,\n\t    enumerable:true\n\t});\n\t\n\t//枚举对象的属性\n\tfor( var attr in obj ){\n\t    console.log( attr );  //newKey\n\t}\n\n4)  configurable\n\n    是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n\n    这个属性起到两个作用：\n\n    1. 目标属性是否可以使用delete删除\n    \n    2. 目标属性是否可以再次设置特性\n    \n\t\t//-----------------测试目标属性是否能被删除------------------------\n\t\tvar obj = {}\n\t\t//第一种情况：configurable设置为false，不能被删除。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:false\n\t\t});\n\t\t//删除属性\n\t\tdelete obj.newKey;\n\t\tconsole.log( obj.newKey ); //hello\n\t\t\n\t\t//第二种情况：configurable设置为true，可以被删除。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:true\n\t\t});\n\t\t//删除属性\n\t\tdelete obj.newKey;\n\t\tconsole.log( obj.newKey ); //undefined\n\t\t\n\t\t//-----------------测试是否可以再次修改特性------------------------\n\t\tvar obj = {}\n\t\t//第一种情况：configurable设置为false，不能再次修改特性。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:false\n\t\t});\n\t\t\n\t\t//重新修改特性\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:true,\n\t\t    enumerable:true,\n\t\t    configurable:true\n\t\t});\n\t\tconsole.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey\n\t\t\n\t\t//第二种情况：configurable设置为true，可以再次修改特性。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:true\n\t\t});\n\t\t\n\t\t//重新修改特性\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:true,\n\t\t    enumerable:true,\n\t\t    configurable:true\n\t\t});\n\t\tconsole.log( obj.newKey ); //hello\n\n除了给新特性的属性设置特性，也可以给已有的属性设置特性。\n\n\t//定义对象的时候添加的属性，是可删除、可重写、可枚举的。\n\tvar obj = {\n\t    test:\"hello\"\n\t}\n\t//改写值\n\tobj.test = 'change value';\n\t\n\tconsole.log( obj.test ); //'change value'\n\t\n\tObject.defineProperty(obj,\"test\",{\n\t    writable:false\n\t})\n\t\n\t//再次改写值\n\tobj.test = 'change value again';\n\tconsole.log( obj.test ); //依然是：'change value'\n\n** 提示： 一旦使用`Object.defineProperty()`给对象添加属性，那么如果不设置属性的特性，那么configrable,enumerable,writable这些值都是默认的false。**\n\n\n    \tvar obj = {};\n    \n    \t定义新属性后，这个属性的特性中，都是默认为false。这就导致了newKey这个是不能重写，不能枚举，不能再次设置特性。\n    \t//\n    \tObject.defineProperty(obj,'newKey',{\n    \t});\n    \t\n    \t//设置值\n    \tobj.newKey = 'hello';\n    \tconsole.log(obj.newKey);  //undefined\n    \t\n    \t//枚举\n    \tfor( var attr in obj ){\n    \t    console.log(attr);\n    \t}\n\n特性总结：\n> value: 设置属性的值\n>writable: 值是否可以重写。true | false\n>enumerable: 目标属性是否可以被枚举。true | false\n>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false\n##### 8、Object.hasOwnProperty（）\n\n> 用于知识一个对象自身是否具有指定名称的属性，如果有返回true， 如果没有返回false。\n\n\t语法 ：object.hasOwnProperty(propertyName)\n\tpropertyName：指定的属性名称\n    返回值： \n    hasOwnProperty（）返回的值是Boolean类型。如果对象Object具有名称为propertyName的属性，则返回true    ,否则返回false。\n\n此方法不会检查对象的原型链中是否存在此属性，该属性只有是对象本身的一个成员才会返回true。\n\n举个例子：\n\t\n\tfunction isHas(){\n\t\tthis.name = 'today',\n\t\tthis.week = 'wendsday',\n\t\tthis.sayHi = function(){\n\t\t\tdocument.writeln('今天是'+this.name);\n\t\t}\n\t}\n\n\tvar obj = {\n\t\tmood = 'happy',\n\t\tsayHello = function(){\n\t\t\tdocument.writeln('今天的心情是'+this.mood);\n\t\t}\n\t}\n//使用对象obj覆盖Site本身的prototype属性\n\n    isHas.prototype = obj;\n    \n    var h = new isHas();\n    document.writeln(s.hasOwnProperty('name')); //true\n    document.writeln(s.hasOwnProperty('sayHi')); //true\n    \n    //以下属性继承自原型链，所以为false\n    document.writeln(s.hasOwnProperty('mood')); //false\n    document.writeln(s.hasOwnProperty('sayHello')); //false\n    \n    // 想要查看对象(包括原型链)是否具备指定的属性，可以使用in操作符\n    document.writeln('mood' in s); //true\n    document.writeln('sayHello' in s); //true\n    \n 完结！ 后续有更新再添加！\n\n\n\n\n\n","source":"_posts/Object类的常用方法（二）.md","raw":"---\ntitle: Object类的常用方法 （二）\n---\n-----------\n> 续上文Object类的常用方法（一）\n\n> 上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()\n本篇文章会有点枯燥捏！\n\n下面就按顺序排了\n##### 5、 Object.entries:\t\n\n> `Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。\n\n    Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。\n\n    参数： Object.entries(obj), 其中 obj 可以返回其可枚举属性的键值对的对象。\n\n    返回值： 给定对象自身可枚举属性的键值对数组。\n\n举个栗子：\n\n\tconst obj = { foo: 'bar', baz: 42 };\n\tconsole.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\t\n\t// array like object\n\tconst obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]\n\t\n\t// array like object with random key ordering\n\tconst anObj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]\n\t\n\t// getFoo is property which isn't enumerable\n\tconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });\n\tmyObj.foo = 'bar';\n\tconsole.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]\n\t\n\t// non-object argument will be coerced to an object\n\tconsole.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]\n\t\n\t// iterate through key-value gracefully\n\tconst obj = { a: 5, b: 7, c: 9 };\n\tfor (const [key, value] of Object.entries(obj)) {\n\t  console.log(`${key} ${value}`); // \"a 5\", \"b 7\", \"c 9\"\n\t}\n\t\n\t// Or, using array extras\n\tObject.entries(obj).forEach(([key, value]) => {\n\tconsole.log(`${key} ${value}`); // \"a 5\", \"b 7\", \"c 9\"\n\t});\n\n\n##### 6、 Object.create:\t\n\t\t\n> ` Object.create()` 方法会使用指定的原型对象及其属性去创建一个新的对象\n> \n> Object.create(proto[, propertiesObject])\n\n> 其中参数proto为一个对象，作为新创建对象的原型\n> \n> propertiesObject: 对象，可选参数，为新创建的对象指定属性对象。\n\n** 注意，使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。**\n\n来看一个简单的例子：\n\n\t// 基类\n\tfunction Site() {\n\t  this.name = 'Site';\n\t  this.domain = 'domain';\n\t}\n\n\tSite.prototype.create = function(name, domain) {\n\t  this.name = name;\n\t  this.domain = domain;\n\t};\n\t\n\t// 子类\n\tfunction Itbilu() {\n\t  Site.call(this); //调用基类的构造函数\n\t}\n\t\n\t// 继承父类\n\tItbilu.prototype = Object.create(Site.prototype);\n\t\n\t// 创建类实例\n\tvar itbilu = new Itbilu();\n\t\n\titbilu instanceof Site;  // true\n\ttbilu instanceof Itbilu;  // true\n\t\n\titbilu.create('IT笔录', 'itbilu.com');\n\titbilu.name;    // 'IT笔录'\n\titbilu.domain;  // 'itbilu.com'\n\n使用 ` Object.create()` 的 propertyObject参数\n\n\tvar o;\n\t\n\t// 创建一个原型为null的空对象\n\to = Object.create(null);\n\t\n\to = {};\n\t// 以字面量方式创建的空对象就相当于:\n\to = Object.create(Object.prototype);\n\t\n\to = Object.create(Object.prototype, {\n\t  // foo会成为所创建对象的数据属性\n\t  foo: { \n\t    writable:true,\n\t    configurable:true,\n\t    value: \"hello\" \n\t  },\n\t  // bar会成为所创建对象的访问器属性\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10 },\n\t    set: function(value) {\n\t      console.log(\"Setting `o.bar` to\", value);\n\t    }\n\t  }\n\t});\n\t\n##### 7、Object.defineProperty\n\t\n\t语法： Object.defineProperty(obj, prop, descriptor)\n\t参数： \n\t\tobj：必需。目标对象 \n\t\tprop：必需。需定义或修改的属性的名字\n\t\tdescriptor：必需。目标属性所拥有的特性\n\t返回值： 传入函数的对象。即第一个参数obj\n\n针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历\n\n给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。\n\n数据描述：\n当修改或者定义对象的某个属性的时候，给这个属性添加一些特性：\n\t\n    var obj = {\n        test:\"hello\"\n    }\n    //对象已有的属性添加特性描述\n    Object.defineProperty(obj,\"test\",{\n        configurable:true | false,\n        enumerable:true | false,\n        value:任意类型的值,\n        writable:true | false\n    });\n    //对象新添加的属性的特性描述\n    Object.defineProperty(obj,\"newKey\",{\n        configurable:true | false,\n        enumerable:true | false,\n        value:任意类型的值,\n        writable:true | false\n    });\n\n数据描述中的属性都是可选的。看一下每个设置的作用。\n\n1) value： 属性对应的值,可以使任意类型的值，默认为undefined\n\n\tvar obj = {};\n\t//第一种情况，不设置value属性。\n\tObject.defineProperty(obj,\"newKey\",{})\n\tconsole.log(obj.newKey);   //undefined\t\n\t//第二种 设置value属性\n\n\tObject.defineProperty(obj,\"newKey\",{\n\t\tvalue： 'hello'\n\t})\n\tconsole.log(obj.newKey);   //hello\t\n\n2) writable \n    属性的值是否可以被重写。设置为true可以被重写，设置为false,不可被重写。 默认为false\n\n\tvar obj = {}\n\t//第一种情况：writable设置为false，不能重写。\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:false\n\t});\n\t//更改newKey的值\n\tobj.newKey = \"change value\";\n\tconsole.log( obj.newKey );  //hello\n\n\t//第二种情况：writable设置为true，可以重写\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:true\n\t});\n\t//更改newKey的值\n\tobj.newKey = \"change value\";\n\tconsole.log( obj.newKey );  //change value\n\n3)  enumerable\n此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。\n\n\tvar obj = {}\n\t//第一种情况：enumerable设置为false，不能被枚举。\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:false,\n\t    enumerable:false\n\t});\n\t\n\t//枚举对象的属性\n\tfor( var attr in obj ){\n\t    console.log( attr );  \n\t}\n\t//第二种情况：enumerable设置为true，可以被枚举。\n\tObject.defineProperty(obj,\"newKey\",{\n\t    value:\"hello\",\n\t    writable:false,\n\t    enumerable:true\n\t});\n\t\n\t//枚举对象的属性\n\tfor( var attr in obj ){\n\t    console.log( attr );  //newKey\n\t}\n\n4)  configurable\n\n    是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n\n    这个属性起到两个作用：\n\n    1. 目标属性是否可以使用delete删除\n    \n    2. 目标属性是否可以再次设置特性\n    \n\t\t//-----------------测试目标属性是否能被删除------------------------\n\t\tvar obj = {}\n\t\t//第一种情况：configurable设置为false，不能被删除。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:false\n\t\t});\n\t\t//删除属性\n\t\tdelete obj.newKey;\n\t\tconsole.log( obj.newKey ); //hello\n\t\t\n\t\t//第二种情况：configurable设置为true，可以被删除。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:true\n\t\t});\n\t\t//删除属性\n\t\tdelete obj.newKey;\n\t\tconsole.log( obj.newKey ); //undefined\n\t\t\n\t\t//-----------------测试是否可以再次修改特性------------------------\n\t\tvar obj = {}\n\t\t//第一种情况：configurable设置为false，不能再次修改特性。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:false\n\t\t});\n\t\t\n\t\t//重新修改特性\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:true,\n\t\t    enumerable:true,\n\t\t    configurable:true\n\t\t});\n\t\tconsole.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey\n\t\t\n\t\t//第二种情况：configurable设置为true，可以再次修改特性。\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:false,\n\t\t    enumerable:false,\n\t\t    configurable:true\n\t\t});\n\t\t\n\t\t//重新修改特性\n\t\tObject.defineProperty(obj,\"newKey\",{\n\t\t    value:\"hello\",\n\t\t    writable:true,\n\t\t    enumerable:true,\n\t\t    configurable:true\n\t\t});\n\t\tconsole.log( obj.newKey ); //hello\n\n除了给新特性的属性设置特性，也可以给已有的属性设置特性。\n\n\t//定义对象的时候添加的属性，是可删除、可重写、可枚举的。\n\tvar obj = {\n\t    test:\"hello\"\n\t}\n\t//改写值\n\tobj.test = 'change value';\n\t\n\tconsole.log( obj.test ); //'change value'\n\t\n\tObject.defineProperty(obj,\"test\",{\n\t    writable:false\n\t})\n\t\n\t//再次改写值\n\tobj.test = 'change value again';\n\tconsole.log( obj.test ); //依然是：'change value'\n\n** 提示： 一旦使用`Object.defineProperty()`给对象添加属性，那么如果不设置属性的特性，那么configrable,enumerable,writable这些值都是默认的false。**\n\n\n    \tvar obj = {};\n    \n    \t定义新属性后，这个属性的特性中，都是默认为false。这就导致了newKey这个是不能重写，不能枚举，不能再次设置特性。\n    \t//\n    \tObject.defineProperty(obj,'newKey',{\n    \t});\n    \t\n    \t//设置值\n    \tobj.newKey = 'hello';\n    \tconsole.log(obj.newKey);  //undefined\n    \t\n    \t//枚举\n    \tfor( var attr in obj ){\n    \t    console.log(attr);\n    \t}\n\n特性总结：\n> value: 设置属性的值\n>writable: 值是否可以重写。true | false\n>enumerable: 目标属性是否可以被枚举。true | false\n>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false\n##### 8、Object.hasOwnProperty（）\n\n> 用于知识一个对象自身是否具有指定名称的属性，如果有返回true， 如果没有返回false。\n\n\t语法 ：object.hasOwnProperty(propertyName)\n\tpropertyName：指定的属性名称\n    返回值： \n    hasOwnProperty（）返回的值是Boolean类型。如果对象Object具有名称为propertyName的属性，则返回true    ,否则返回false。\n\n此方法不会检查对象的原型链中是否存在此属性，该属性只有是对象本身的一个成员才会返回true。\n\n举个例子：\n\t\n\tfunction isHas(){\n\t\tthis.name = 'today',\n\t\tthis.week = 'wendsday',\n\t\tthis.sayHi = function(){\n\t\t\tdocument.writeln('今天是'+this.name);\n\t\t}\n\t}\n\n\tvar obj = {\n\t\tmood = 'happy',\n\t\tsayHello = function(){\n\t\t\tdocument.writeln('今天的心情是'+this.mood);\n\t\t}\n\t}\n//使用对象obj覆盖Site本身的prototype属性\n\n    isHas.prototype = obj;\n    \n    var h = new isHas();\n    document.writeln(s.hasOwnProperty('name')); //true\n    document.writeln(s.hasOwnProperty('sayHi')); //true\n    \n    //以下属性继承自原型链，所以为false\n    document.writeln(s.hasOwnProperty('mood')); //false\n    document.writeln(s.hasOwnProperty('sayHello')); //false\n    \n    // 想要查看对象(包括原型链)是否具备指定的属性，可以使用in操作符\n    document.writeln('mood' in s); //true\n    document.writeln('sayHello' in s); //true\n    \n 完结！ 后续有更新再添加！\n\n\n\n\n\n","slug":"Object类的常用方法（二）","published":1,"date":"2018-06-20T12:30:14.000Z","updated":"2018-06-20T12:30:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpory0001g4s6zpas00kv","content":"<hr>\n<blockquote>\n<p>续上文Object类的常用方法（一）</p>\n</blockquote>\n<blockquote>\n<p>上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()<br>本篇文章会有点枯燥捏！</p>\n</blockquote>\n<p>下面就按顺序排了</p>\n<h5 id=\"5、-Object-entries\"><a href=\"#5、-Object-entries\" class=\"headerlink\" title=\"5、 Object.entries:\"></a>5、 Object.entries:</h5><blockquote>\n<p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>\n</blockquote>\n<pre><code>Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。\n\n参数： Object.entries(obj), 其中 obj 可以返回其可枚举属性的键值对的对象。\n\n返回值： 给定对象自身可枚举属性的键值对数组。\n</code></pre><p>举个栗子：</p>\n<pre><code>const obj = { foo: &apos;bar&apos;, baz: 42 };\nconsole.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]\n\n// array like object\nconst obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };\nconsole.log(Object.entries(obj)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]\n\n// array like object with random key ordering\nconst anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };\nconsole.log(Object.entries(anObj)); // [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]\n\n// getFoo is property which isn&apos;t enumerable\nconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });\nmyObj.foo = &apos;bar&apos;;\nconsole.log(Object.entries(myObj)); // [ [&apos;foo&apos;, &apos;bar&apos;] ]\n\n// non-object argument will be coerced to an object\nconsole.log(Object.entries(&apos;foo&apos;)); // [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]\n\n// iterate through key-value gracefully\nconst obj = { a: 5, b: 7, c: 9 };\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n}\n\n// Or, using array extras\nObject.entries(obj).forEach(([key, value]) =&gt; {\nconsole.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n});\n</code></pre><h5 id=\"6、-Object-create\"><a href=\"#6、-Object-create\" class=\"headerlink\" title=\"6、 Object.create:\"></a>6、 Object.create:</h5><blockquote>\n<p><code>Object.create()</code> 方法会使用指定的原型对象及其属性去创建一个新的对象</p>\n<p>Object.create(proto[, propertiesObject])</p>\n</blockquote>\n<blockquote>\n<p>其中参数proto为一个对象，作为新创建对象的原型</p>\n<p>propertiesObject: 对象，可选参数，为新创建的对象指定属性对象。</p>\n</blockquote>\n<p><strong> 注意，使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。</strong></p>\n<p>来看一个简单的例子：</p>\n<pre><code>// 基类\nfunction Site() {\n  this.name = &apos;Site&apos;;\n  this.domain = &apos;domain&apos;;\n}\n\nSite.prototype.create = function(name, domain) {\n  this.name = name;\n  this.domain = domain;\n};\n\n// 子类\nfunction Itbilu() {\n  Site.call(this); //调用基类的构造函数\n}\n\n// 继承父类\nItbilu.prototype = Object.create(Site.prototype);\n\n// 创建类实例\nvar itbilu = new Itbilu();\n\nitbilu instanceof Site;  // true\ntbilu instanceof Itbilu;  // true\n\nitbilu.create(&apos;IT笔录&apos;, &apos;itbilu.com&apos;);\nitbilu.name;    // &apos;IT笔录&apos;\nitbilu.domain;  // &apos;itbilu.com&apos;\n</code></pre><p>使用 <code>Object.create()</code> 的 propertyObject参数</p>\n<pre><code>var o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: { \n    writable:true,\n    configurable:true,\n    value: &quot;hello&quot; \n  },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) {\n      console.log(&quot;Setting `o.bar` to&quot;, value);\n    }\n  }\n});\n</code></pre><h5 id=\"7、Object-defineProperty\"><a href=\"#7、Object-defineProperty\" class=\"headerlink\" title=\"7、Object.defineProperty\"></a>7、Object.defineProperty</h5><pre><code>语法： Object.defineProperty(obj, prop, descriptor)\n参数： \n    obj：必需。目标对象 \n    prop：必需。需定义或修改的属性的名字\n    descriptor：必需。目标属性所拥有的特性\n返回值： 传入函数的对象。即第一个参数obj\n</code></pre><p>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历</p>\n<p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p>\n<p>数据描述：<br>当修改或者定义对象的某个属性的时候，给这个属性添加一些特性：</p>\n<pre><code>var obj = {\n    test:&quot;hello&quot;\n}\n//对象已有的属性添加特性描述\nObject.defineProperty(obj,&quot;test&quot;,{\n    configurable:true | false,\n    enumerable:true | false,\n    value:任意类型的值,\n    writable:true | false\n});\n//对象新添加的属性的特性描述\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    configurable:true | false,\n    enumerable:true | false,\n    value:任意类型的值,\n    writable:true | false\n});\n</code></pre><p>数据描述中的属性都是可选的。看一下每个设置的作用。</p>\n<p>1) value： 属性对应的值,可以使任意类型的值，默认为undefined</p>\n<pre><code>var obj = {};\n//第一种情况，不设置value属性。\nObject.defineProperty(obj,&quot;newKey&quot;,{})\nconsole.log(obj.newKey);   //undefined    \n//第二种 设置value属性\n\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value： &apos;hello&apos;\n})\nconsole.log(obj.newKey);   //hello    \n</code></pre><p>2) writable<br>    属性的值是否可以被重写。设置为true可以被重写，设置为false,不可被重写。 默认为false</p>\n<pre><code>var obj = {}\n//第一种情况：writable设置为false，不能重写。\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:false\n});\n//更改newKey的值\nobj.newKey = &quot;change value&quot;;\nconsole.log( obj.newKey );  //hello\n\n//第二种情况：writable设置为true，可以重写\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:true\n});\n//更改newKey的值\nobj.newKey = &quot;change value&quot;;\nconsole.log( obj.newKey );  //change value\n</code></pre><p>3)  enumerable<br>此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p>\n<pre><code>var obj = {}\n//第一种情况：enumerable设置为false，不能被枚举。\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:false,\n    enumerable:false\n});\n\n//枚举对象的属性\nfor( var attr in obj ){\n    console.log( attr );  \n}\n//第二种情况：enumerable设置为true，可以被枚举。\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:false,\n    enumerable:true\n});\n\n//枚举对象的属性\nfor( var attr in obj ){\n    console.log( attr );  //newKey\n}\n</code></pre><p>4)  configurable</p>\n<pre><code>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n\n这个属性起到两个作用：\n\n1. 目标属性是否可以使用delete删除\n\n2. 目标属性是否可以再次设置特性\n\n    //-----------------测试目标属性是否能被删除------------------------\n    var obj = {}\n    //第一种情况：configurable设置为false，不能被删除。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:false\n    });\n    //删除属性\n    delete obj.newKey;\n    console.log( obj.newKey ); //hello\n\n    //第二种情况：configurable设置为true，可以被删除。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:true\n    });\n    //删除属性\n    delete obj.newKey;\n    console.log( obj.newKey ); //undefined\n\n    //-----------------测试是否可以再次修改特性------------------------\n    var obj = {}\n    //第一种情况：configurable设置为false，不能再次修改特性。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:false\n    });\n\n    //重新修改特性\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:true,\n        enumerable:true,\n        configurable:true\n    });\n    console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey\n\n    //第二种情况：configurable设置为true，可以再次修改特性。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:true\n    });\n\n    //重新修改特性\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:true,\n        enumerable:true,\n        configurable:true\n    });\n    console.log( obj.newKey ); //hello\n</code></pre><p>除了给新特性的属性设置特性，也可以给已有的属性设置特性。</p>\n<pre><code>//定义对象的时候添加的属性，是可删除、可重写、可枚举的。\nvar obj = {\n    test:&quot;hello&quot;\n}\n//改写值\nobj.test = &apos;change value&apos;;\n\nconsole.log( obj.test ); //&apos;change value&apos;\n\nObject.defineProperty(obj,&quot;test&quot;,{\n    writable:false\n})\n\n//再次改写值\nobj.test = &apos;change value again&apos;;\nconsole.log( obj.test ); //依然是：&apos;change value&apos;\n</code></pre><p><strong> 提示： 一旦使用<code>Object.defineProperty()</code>给对象添加属性，那么如果不设置属性的特性，那么configrable,enumerable,writable这些值都是默认的false。</strong></p>\n<pre><code>var obj = {};\n\n定义新属性后，这个属性的特性中，都是默认为false。这就导致了newKey这个是不能重写，不能枚举，不能再次设置特性。\n//\nObject.defineProperty(obj,&apos;newKey&apos;,{\n});\n\n//设置值\nobj.newKey = &apos;hello&apos;;\nconsole.log(obj.newKey);  //undefined\n\n//枚举\nfor( var attr in obj ){\n    console.log(attr);\n}\n</code></pre><p>特性总结：</p>\n<blockquote>\n<p>value: 设置属性的值<br>writable: 值是否可以重写。true | false<br>enumerable: 目标属性是否可以被枚举。true | false<br>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false</p>\n</blockquote>\n<h5 id=\"8、Object-hasOwnProperty（）\"><a href=\"#8、Object-hasOwnProperty（）\" class=\"headerlink\" title=\"8、Object.hasOwnProperty（）\"></a>8、Object.hasOwnProperty（）</h5><blockquote>\n<p>用于知识一个对象自身是否具有指定名称的属性，如果有返回true， 如果没有返回false。</p>\n</blockquote>\n<pre><code>语法 ：object.hasOwnProperty(propertyName)\npropertyName：指定的属性名称\n返回值： \nhasOwnProperty（）返回的值是Boolean类型。如果对象Object具有名称为propertyName的属性，则返回true    ,否则返回false。\n</code></pre><p>此方法不会检查对象的原型链中是否存在此属性，该属性只有是对象本身的一个成员才会返回true。</p>\n<p>举个例子：</p>\n<pre><code>function isHas(){\n    this.name = &apos;today&apos;,\n    this.week = &apos;wendsday&apos;,\n    this.sayHi = function(){\n        document.writeln(&apos;今天是&apos;+this.name);\n    }\n}\n\nvar obj = {\n    mood = &apos;happy&apos;,\n    sayHello = function(){\n        document.writeln(&apos;今天的心情是&apos;+this.mood);\n    }\n}\n</code></pre><p>//使用对象obj覆盖Site本身的prototype属性</p>\n<pre><code>isHas.prototype = obj;\n\nvar h = new isHas();\ndocument.writeln(s.hasOwnProperty(&apos;name&apos;)); //true\ndocument.writeln(s.hasOwnProperty(&apos;sayHi&apos;)); //true\n\n//以下属性继承自原型链，所以为false\ndocument.writeln(s.hasOwnProperty(&apos;mood&apos;)); //false\ndocument.writeln(s.hasOwnProperty(&apos;sayHello&apos;)); //false\n\n// 想要查看对象(包括原型链)是否具备指定的属性，可以使用in操作符\ndocument.writeln(&apos;mood&apos; in s); //true\ndocument.writeln(&apos;sayHello&apos; in s); //true\n</code></pre><p> 完结！ 后续有更新再添加！</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<blockquote>\n<p>续上文Object类的常用方法（一）</p>\n</blockquote>\n<blockquote>\n<p>上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()<br>本篇文章会有点枯燥捏！</p>\n</blockquote>\n<p>下面就按顺序排了</p>\n<h5 id=\"5、-Object-entries\"><a href=\"#5、-Object-entries\" class=\"headerlink\" title=\"5、 Object.entries:\"></a>5、 Object.entries:</h5><blockquote>\n<p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>\n</blockquote>\n<pre><code>Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。\n\n参数： Object.entries(obj), 其中 obj 可以返回其可枚举属性的键值对的对象。\n\n返回值： 给定对象自身可枚举属性的键值对数组。\n</code></pre><p>举个栗子：</p>\n<pre><code>const obj = { foo: &apos;bar&apos;, baz: 42 };\nconsole.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]\n\n// array like object\nconst obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };\nconsole.log(Object.entries(obj)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]\n\n// array like object with random key ordering\nconst anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };\nconsole.log(Object.entries(anObj)); // [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]\n\n// getFoo is property which isn&apos;t enumerable\nconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });\nmyObj.foo = &apos;bar&apos;;\nconsole.log(Object.entries(myObj)); // [ [&apos;foo&apos;, &apos;bar&apos;] ]\n\n// non-object argument will be coerced to an object\nconsole.log(Object.entries(&apos;foo&apos;)); // [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]\n\n// iterate through key-value gracefully\nconst obj = { a: 5, b: 7, c: 9 };\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n}\n\n// Or, using array extras\nObject.entries(obj).forEach(([key, value]) =&gt; {\nconsole.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n});\n</code></pre><h5 id=\"6、-Object-create\"><a href=\"#6、-Object-create\" class=\"headerlink\" title=\"6、 Object.create:\"></a>6、 Object.create:</h5><blockquote>\n<p><code>Object.create()</code> 方法会使用指定的原型对象及其属性去创建一个新的对象</p>\n<p>Object.create(proto[, propertiesObject])</p>\n</blockquote>\n<blockquote>\n<p>其中参数proto为一个对象，作为新创建对象的原型</p>\n<p>propertiesObject: 对象，可选参数，为新创建的对象指定属性对象。</p>\n</blockquote>\n<p><strong> 注意，使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。</strong></p>\n<p>来看一个简单的例子：</p>\n<pre><code>// 基类\nfunction Site() {\n  this.name = &apos;Site&apos;;\n  this.domain = &apos;domain&apos;;\n}\n\nSite.prototype.create = function(name, domain) {\n  this.name = name;\n  this.domain = domain;\n};\n\n// 子类\nfunction Itbilu() {\n  Site.call(this); //调用基类的构造函数\n}\n\n// 继承父类\nItbilu.prototype = Object.create(Site.prototype);\n\n// 创建类实例\nvar itbilu = new Itbilu();\n\nitbilu instanceof Site;  // true\ntbilu instanceof Itbilu;  // true\n\nitbilu.create(&apos;IT笔录&apos;, &apos;itbilu.com&apos;);\nitbilu.name;    // &apos;IT笔录&apos;\nitbilu.domain;  // &apos;itbilu.com&apos;\n</code></pre><p>使用 <code>Object.create()</code> 的 propertyObject参数</p>\n<pre><code>var o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: { \n    writable:true,\n    configurable:true,\n    value: &quot;hello&quot; \n  },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) {\n      console.log(&quot;Setting `o.bar` to&quot;, value);\n    }\n  }\n});\n</code></pre><h5 id=\"7、Object-defineProperty\"><a href=\"#7、Object-defineProperty\" class=\"headerlink\" title=\"7、Object.defineProperty\"></a>7、Object.defineProperty</h5><pre><code>语法： Object.defineProperty(obj, prop, descriptor)\n参数： \n    obj：必需。目标对象 \n    prop：必需。需定义或修改的属性的名字\n    descriptor：必需。目标属性所拥有的特性\n返回值： 传入函数的对象。即第一个参数obj\n</code></pre><p>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历</p>\n<p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p>\n<p>数据描述：<br>当修改或者定义对象的某个属性的时候，给这个属性添加一些特性：</p>\n<pre><code>var obj = {\n    test:&quot;hello&quot;\n}\n//对象已有的属性添加特性描述\nObject.defineProperty(obj,&quot;test&quot;,{\n    configurable:true | false,\n    enumerable:true | false,\n    value:任意类型的值,\n    writable:true | false\n});\n//对象新添加的属性的特性描述\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    configurable:true | false,\n    enumerable:true | false,\n    value:任意类型的值,\n    writable:true | false\n});\n</code></pre><p>数据描述中的属性都是可选的。看一下每个设置的作用。</p>\n<p>1) value： 属性对应的值,可以使任意类型的值，默认为undefined</p>\n<pre><code>var obj = {};\n//第一种情况，不设置value属性。\nObject.defineProperty(obj,&quot;newKey&quot;,{})\nconsole.log(obj.newKey);   //undefined    \n//第二种 设置value属性\n\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value： &apos;hello&apos;\n})\nconsole.log(obj.newKey);   //hello    \n</code></pre><p>2) writable<br>    属性的值是否可以被重写。设置为true可以被重写，设置为false,不可被重写。 默认为false</p>\n<pre><code>var obj = {}\n//第一种情况：writable设置为false，不能重写。\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:false\n});\n//更改newKey的值\nobj.newKey = &quot;change value&quot;;\nconsole.log( obj.newKey );  //hello\n\n//第二种情况：writable设置为true，可以重写\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:true\n});\n//更改newKey的值\nobj.newKey = &quot;change value&quot;;\nconsole.log( obj.newKey );  //change value\n</code></pre><p>3)  enumerable<br>此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p>\n<pre><code>var obj = {}\n//第一种情况：enumerable设置为false，不能被枚举。\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:false,\n    enumerable:false\n});\n\n//枚举对象的属性\nfor( var attr in obj ){\n    console.log( attr );  \n}\n//第二种情况：enumerable设置为true，可以被枚举。\nObject.defineProperty(obj,&quot;newKey&quot;,{\n    value:&quot;hello&quot;,\n    writable:false,\n    enumerable:true\n});\n\n//枚举对象的属性\nfor( var attr in obj ){\n    console.log( attr );  //newKey\n}\n</code></pre><p>4)  configurable</p>\n<pre><code>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n\n这个属性起到两个作用：\n\n1. 目标属性是否可以使用delete删除\n\n2. 目标属性是否可以再次设置特性\n\n    //-----------------测试目标属性是否能被删除------------------------\n    var obj = {}\n    //第一种情况：configurable设置为false，不能被删除。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:false\n    });\n    //删除属性\n    delete obj.newKey;\n    console.log( obj.newKey ); //hello\n\n    //第二种情况：configurable设置为true，可以被删除。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:true\n    });\n    //删除属性\n    delete obj.newKey;\n    console.log( obj.newKey ); //undefined\n\n    //-----------------测试是否可以再次修改特性------------------------\n    var obj = {}\n    //第一种情况：configurable设置为false，不能再次修改特性。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:false\n    });\n\n    //重新修改特性\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:true,\n        enumerable:true,\n        configurable:true\n    });\n    console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey\n\n    //第二种情况：configurable设置为true，可以再次修改特性。\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:false,\n        enumerable:false,\n        configurable:true\n    });\n\n    //重新修改特性\n    Object.defineProperty(obj,&quot;newKey&quot;,{\n        value:&quot;hello&quot;,\n        writable:true,\n        enumerable:true,\n        configurable:true\n    });\n    console.log( obj.newKey ); //hello\n</code></pre><p>除了给新特性的属性设置特性，也可以给已有的属性设置特性。</p>\n<pre><code>//定义对象的时候添加的属性，是可删除、可重写、可枚举的。\nvar obj = {\n    test:&quot;hello&quot;\n}\n//改写值\nobj.test = &apos;change value&apos;;\n\nconsole.log( obj.test ); //&apos;change value&apos;\n\nObject.defineProperty(obj,&quot;test&quot;,{\n    writable:false\n})\n\n//再次改写值\nobj.test = &apos;change value again&apos;;\nconsole.log( obj.test ); //依然是：&apos;change value&apos;\n</code></pre><p><strong> 提示： 一旦使用<code>Object.defineProperty()</code>给对象添加属性，那么如果不设置属性的特性，那么configrable,enumerable,writable这些值都是默认的false。</strong></p>\n<pre><code>var obj = {};\n\n定义新属性后，这个属性的特性中，都是默认为false。这就导致了newKey这个是不能重写，不能枚举，不能再次设置特性。\n//\nObject.defineProperty(obj,&apos;newKey&apos;,{\n});\n\n//设置值\nobj.newKey = &apos;hello&apos;;\nconsole.log(obj.newKey);  //undefined\n\n//枚举\nfor( var attr in obj ){\n    console.log(attr);\n}\n</code></pre><p>特性总结：</p>\n<blockquote>\n<p>value: 设置属性的值<br>writable: 值是否可以重写。true | false<br>enumerable: 目标属性是否可以被枚举。true | false<br>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false</p>\n</blockquote>\n<h5 id=\"8、Object-hasOwnProperty（）\"><a href=\"#8、Object-hasOwnProperty（）\" class=\"headerlink\" title=\"8、Object.hasOwnProperty（）\"></a>8、Object.hasOwnProperty（）</h5><blockquote>\n<p>用于知识一个对象自身是否具有指定名称的属性，如果有返回true， 如果没有返回false。</p>\n</blockquote>\n<pre><code>语法 ：object.hasOwnProperty(propertyName)\npropertyName：指定的属性名称\n返回值： \nhasOwnProperty（）返回的值是Boolean类型。如果对象Object具有名称为propertyName的属性，则返回true    ,否则返回false。\n</code></pre><p>此方法不会检查对象的原型链中是否存在此属性，该属性只有是对象本身的一个成员才会返回true。</p>\n<p>举个例子：</p>\n<pre><code>function isHas(){\n    this.name = &apos;today&apos;,\n    this.week = &apos;wendsday&apos;,\n    this.sayHi = function(){\n        document.writeln(&apos;今天是&apos;+this.name);\n    }\n}\n\nvar obj = {\n    mood = &apos;happy&apos;,\n    sayHello = function(){\n        document.writeln(&apos;今天的心情是&apos;+this.mood);\n    }\n}\n</code></pre><p>//使用对象obj覆盖Site本身的prototype属性</p>\n<pre><code>isHas.prototype = obj;\n\nvar h = new isHas();\ndocument.writeln(s.hasOwnProperty(&apos;name&apos;)); //true\ndocument.writeln(s.hasOwnProperty(&apos;sayHi&apos;)); //true\n\n//以下属性继承自原型链，所以为false\ndocument.writeln(s.hasOwnProperty(&apos;mood&apos;)); //false\ndocument.writeln(s.hasOwnProperty(&apos;sayHello&apos;)); //false\n\n// 想要查看对象(包括原型链)是否具备指定的属性，可以使用in操作符\ndocument.writeln(&apos;mood&apos; in s); //true\ndocument.writeln(&apos;sayHello&apos; in s); //true\n</code></pre><p> 完结！ 后续有更新再添加！</p>\n"},{"title":"浏览器","_content":"\n### 此处遇到浏览器问题","source":"_posts/css.md","raw":"---\ntitle: 浏览器\n---\n\n### 此处遇到浏览器问题","slug":"css","published":1,"date":"2017-12-26T06:29:32.000Z","updated":"2017-12-26T06:29:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos00002g4s6pewpkv29","content":"<h3 id=\"此处遇到浏览器问题\"><a href=\"#此处遇到浏览器问题\" class=\"headerlink\" title=\"此处遇到浏览器问题\"></a>此处遇到浏览器问题</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"此处遇到浏览器问题\"><a href=\"#此处遇到浏览器问题\" class=\"headerlink\" title=\"此处遇到浏览器问题\"></a>此处遇到浏览器问题</h3>"},{"title":"es6箭头函数和普通函数的区别","_content":"\n### 1、 写法：\n\t\t箭头函数：\n\t\tvar a = >{\n\t\t\t\tconsole.log(b)\n\t\t\t}\n\t\t\n\t\t普通函数：\n\t\t\tfunction a(){\n\t\t\t\tconsole.log(b)\n\t\t\t}\n\t\t\n### 2. 箭头函数不能作为构造函数\n\n\t\tvar a =() =>{\n\t\t\tconsole.log(b);\n\t\t }\n\t\t var b = new a(); //TypeError  a is not a constructor\n\n### 3.箭头函数不绑定arguments,取而代之用rest参数...解决。\n\n\t\tfunction A(a){\n\t\t\tconsole.log(arguments)\n\t\t}\n\t\t\n\t\tvar B = (b) =>{\n\t\t\tconsole.log(arguments);  \n\t\t}\n\t\t\n\t\tvar C = (...c) =>{\n\t\t\tconsole.log(c)\n\t\t}\n\t\t\n\t\tA(1);\n\t\tB(2);  //arguments is not defined\n\t\tC(3);\n\n### 4.箭头函数会捕获其所在上下文的this值，作为自己的this值。\n\n\tvar Obj = {\n\t\ta: 10,\n\t\tb: function(){\n\t\t\tconsole.log(this.a);\n\t\t},\n\t\tc: function(){\n\t\t\treturn ()=>{\n\t\t\t\tconsole.log(this.a);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tObj.b();\n\tObj.c()();\n\n### 5.使用call() 和 apply()调用；\n\n\t通过call()和apply()方法调用一个函数时。只是传入了参数而已，对this并没有什么影响。\n\tvar Obj = {\n\t\ta: 10,\n\t\tb: function(n){\n\t\t\tvar f = (v) => v+this.a\n\t\t\treturn f(n)\n\t\t},\n\t\tc: function(n){\n\t\t\tvar f = (v) => v+this.a\n\t\t\tvar m = {a:20};\n\t\t\treturn f.call(m,n)\n\t\t}\n\t}\n\t\n\tconsole.log(Obj.b(1)); //11\n\tconsole.log(Obj.c(1)); //11\n\t\n### 6.箭头函数没有原型属性。\n\n\tvar a =() =>{\n\t\treturn 1;\n\t}\n\t\n\tfunction b(){\n\t\treturn 2;\n\t}\n\t\n\tconsole.log(a.prototype); //undefined\n\tconsole.log(b.prototype); // object{...}\n\t\n### 7.箭头函数不能换行\n\n\tvar a = () =>\n\t{\n\t}\n\n## 函数的this指向问题：\n\n\t箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()\n\t普通函数的this指向调用它的那个对象\n\t\n\t","source":"_posts/es6箭头函数和普通函数的区别.md","raw":"---\ntitle: es6箭头函数和普通函数的区别\n---\n\n### 1、 写法：\n\t\t箭头函数：\n\t\tvar a = >{\n\t\t\t\tconsole.log(b)\n\t\t\t}\n\t\t\n\t\t普通函数：\n\t\t\tfunction a(){\n\t\t\t\tconsole.log(b)\n\t\t\t}\n\t\t\n### 2. 箭头函数不能作为构造函数\n\n\t\tvar a =() =>{\n\t\t\tconsole.log(b);\n\t\t }\n\t\t var b = new a(); //TypeError  a is not a constructor\n\n### 3.箭头函数不绑定arguments,取而代之用rest参数...解决。\n\n\t\tfunction A(a){\n\t\t\tconsole.log(arguments)\n\t\t}\n\t\t\n\t\tvar B = (b) =>{\n\t\t\tconsole.log(arguments);  \n\t\t}\n\t\t\n\t\tvar C = (...c) =>{\n\t\t\tconsole.log(c)\n\t\t}\n\t\t\n\t\tA(1);\n\t\tB(2);  //arguments is not defined\n\t\tC(3);\n\n### 4.箭头函数会捕获其所在上下文的this值，作为自己的this值。\n\n\tvar Obj = {\n\t\ta: 10,\n\t\tb: function(){\n\t\t\tconsole.log(this.a);\n\t\t},\n\t\tc: function(){\n\t\t\treturn ()=>{\n\t\t\t\tconsole.log(this.a);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tObj.b();\n\tObj.c()();\n\n### 5.使用call() 和 apply()调用；\n\n\t通过call()和apply()方法调用一个函数时。只是传入了参数而已，对this并没有什么影响。\n\tvar Obj = {\n\t\ta: 10,\n\t\tb: function(n){\n\t\t\tvar f = (v) => v+this.a\n\t\t\treturn f(n)\n\t\t},\n\t\tc: function(n){\n\t\t\tvar f = (v) => v+this.a\n\t\t\tvar m = {a:20};\n\t\t\treturn f.call(m,n)\n\t\t}\n\t}\n\t\n\tconsole.log(Obj.b(1)); //11\n\tconsole.log(Obj.c(1)); //11\n\t\n### 6.箭头函数没有原型属性。\n\n\tvar a =() =>{\n\t\treturn 1;\n\t}\n\t\n\tfunction b(){\n\t\treturn 2;\n\t}\n\t\n\tconsole.log(a.prototype); //undefined\n\tconsole.log(b.prototype); // object{...}\n\t\n### 7.箭头函数不能换行\n\n\tvar a = () =>\n\t{\n\t}\n\n## 函数的this指向问题：\n\n\t箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()\n\t普通函数的this指向调用它的那个对象\n\t\n\t","slug":"es6箭头函数和普通函数的区别","published":1,"date":"2018-05-16T09:05:58.000Z","updated":"2018-05-16T09:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos10003g4s6jlvo49mw","content":"<h3 id=\"1、-写法：\"><a href=\"#1、-写法：\" class=\"headerlink\" title=\"1、 写法：\"></a>1、 写法：</h3><pre><code>箭头函数：\nvar a = &gt;{\n        console.log(b)\n    }\n\n普通函数：\n    function a(){\n        console.log(b)\n    }\n</code></pre><h3 id=\"2-箭头函数不能作为构造函数\"><a href=\"#2-箭头函数不能作为构造函数\" class=\"headerlink\" title=\"2. 箭头函数不能作为构造函数\"></a>2. 箭头函数不能作为构造函数</h3><pre><code>var a =() =&gt;{\n    console.log(b);\n }\n var b = new a(); //TypeError  a is not a constructor\n</code></pre><h3 id=\"3-箭头函数不绑定arguments-取而代之用rest参数…解决。\"><a href=\"#3-箭头函数不绑定arguments-取而代之用rest参数…解决。\" class=\"headerlink\" title=\"3.箭头函数不绑定arguments,取而代之用rest参数…解决。\"></a>3.箭头函数不绑定arguments,取而代之用rest参数…解决。</h3><pre><code>function A(a){\n    console.log(arguments)\n}\n\nvar B = (b) =&gt;{\n    console.log(arguments);  \n}\n\nvar C = (...c) =&gt;{\n    console.log(c)\n}\n\nA(1);\nB(2);  //arguments is not defined\nC(3);\n</code></pre><h3 id=\"4-箭头函数会捕获其所在上下文的this值，作为自己的this值。\"><a href=\"#4-箭头函数会捕获其所在上下文的this值，作为自己的this值。\" class=\"headerlink\" title=\"4.箭头函数会捕获其所在上下文的this值，作为自己的this值。\"></a>4.箭头函数会捕获其所在上下文的this值，作为自己的this值。</h3><pre><code>var Obj = {\n    a: 10,\n    b: function(){\n        console.log(this.a);\n    },\n    c: function(){\n        return ()=&gt;{\n            console.log(this.a);\n        }\n    }\n\n}\nObj.b();\nObj.c()();\n</code></pre><h3 id=\"5-使用call-和-apply-调用；\"><a href=\"#5-使用call-和-apply-调用；\" class=\"headerlink\" title=\"5.使用call() 和 apply()调用；\"></a>5.使用call() 和 apply()调用；</h3><pre><code>通过call()和apply()方法调用一个函数时。只是传入了参数而已，对this并没有什么影响。\nvar Obj = {\n    a: 10,\n    b: function(n){\n        var f = (v) =&gt; v+this.a\n        return f(n)\n    },\n    c: function(n){\n        var f = (v) =&gt; v+this.a\n        var m = {a:20};\n        return f.call(m,n)\n    }\n}\n\nconsole.log(Obj.b(1)); //11\nconsole.log(Obj.c(1)); //11\n</code></pre><h3 id=\"6-箭头函数没有原型属性。\"><a href=\"#6-箭头函数没有原型属性。\" class=\"headerlink\" title=\"6.箭头函数没有原型属性。\"></a>6.箭头函数没有原型属性。</h3><pre><code>var a =() =&gt;{\n    return 1;\n}\n\nfunction b(){\n    return 2;\n}\n\nconsole.log(a.prototype); //undefined\nconsole.log(b.prototype); // object{...}\n</code></pre><h3 id=\"7-箭头函数不能换行\"><a href=\"#7-箭头函数不能换行\" class=\"headerlink\" title=\"7.箭头函数不能换行\"></a>7.箭头函数不能换行</h3><pre><code>var a = () =&gt;\n{\n}\n</code></pre><h2 id=\"函数的this指向问题：\"><a href=\"#函数的this指向问题：\" class=\"headerlink\" title=\"函数的this指向问题：\"></a>函数的this指向问题：</h2><pre><code>箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()\n普通函数的this指向调用它的那个对象\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、-写法：\"><a href=\"#1、-写法：\" class=\"headerlink\" title=\"1、 写法：\"></a>1、 写法：</h3><pre><code>箭头函数：\nvar a = &gt;{\n        console.log(b)\n    }\n\n普通函数：\n    function a(){\n        console.log(b)\n    }\n</code></pre><h3 id=\"2-箭头函数不能作为构造函数\"><a href=\"#2-箭头函数不能作为构造函数\" class=\"headerlink\" title=\"2. 箭头函数不能作为构造函数\"></a>2. 箭头函数不能作为构造函数</h3><pre><code>var a =() =&gt;{\n    console.log(b);\n }\n var b = new a(); //TypeError  a is not a constructor\n</code></pre><h3 id=\"3-箭头函数不绑定arguments-取而代之用rest参数…解决。\"><a href=\"#3-箭头函数不绑定arguments-取而代之用rest参数…解决。\" class=\"headerlink\" title=\"3.箭头函数不绑定arguments,取而代之用rest参数…解决。\"></a>3.箭头函数不绑定arguments,取而代之用rest参数…解决。</h3><pre><code>function A(a){\n    console.log(arguments)\n}\n\nvar B = (b) =&gt;{\n    console.log(arguments);  \n}\n\nvar C = (...c) =&gt;{\n    console.log(c)\n}\n\nA(1);\nB(2);  //arguments is not defined\nC(3);\n</code></pre><h3 id=\"4-箭头函数会捕获其所在上下文的this值，作为自己的this值。\"><a href=\"#4-箭头函数会捕获其所在上下文的this值，作为自己的this值。\" class=\"headerlink\" title=\"4.箭头函数会捕获其所在上下文的this值，作为自己的this值。\"></a>4.箭头函数会捕获其所在上下文的this值，作为自己的this值。</h3><pre><code>var Obj = {\n    a: 10,\n    b: function(){\n        console.log(this.a);\n    },\n    c: function(){\n        return ()=&gt;{\n            console.log(this.a);\n        }\n    }\n\n}\nObj.b();\nObj.c()();\n</code></pre><h3 id=\"5-使用call-和-apply-调用；\"><a href=\"#5-使用call-和-apply-调用；\" class=\"headerlink\" title=\"5.使用call() 和 apply()调用；\"></a>5.使用call() 和 apply()调用；</h3><pre><code>通过call()和apply()方法调用一个函数时。只是传入了参数而已，对this并没有什么影响。\nvar Obj = {\n    a: 10,\n    b: function(n){\n        var f = (v) =&gt; v+this.a\n        return f(n)\n    },\n    c: function(n){\n        var f = (v) =&gt; v+this.a\n        var m = {a:20};\n        return f.call(m,n)\n    }\n}\n\nconsole.log(Obj.b(1)); //11\nconsole.log(Obj.c(1)); //11\n</code></pre><h3 id=\"6-箭头函数没有原型属性。\"><a href=\"#6-箭头函数没有原型属性。\" class=\"headerlink\" title=\"6.箭头函数没有原型属性。\"></a>6.箭头函数没有原型属性。</h3><pre><code>var a =() =&gt;{\n    return 1;\n}\n\nfunction b(){\n    return 2;\n}\n\nconsole.log(a.prototype); //undefined\nconsole.log(b.prototype); // object{...}\n</code></pre><h3 id=\"7-箭头函数不能换行\"><a href=\"#7-箭头函数不能换行\" class=\"headerlink\" title=\"7.箭头函数不能换行\"></a>7.箭头函数不能换行</h3><pre><code>var a = () =&gt;\n{\n}\n</code></pre><h2 id=\"函数的this指向问题：\"><a href=\"#函数的this指向问题：\" class=\"headerlink\" title=\"函数的this指向问题：\"></a>函数的this指向问题：</h2><pre><code>箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()\n普通函数的this指向调用它的那个对象\n</code></pre>"},{"title":"ES6和ES7","_content":"\n####  首先说下es6语法糖  \n1. let\n\n2. const\n\n3. 箭头函数\n\n4. 解构赋值\n\n5. promise\n\n\t\n\n\n\n","source":"_posts/es6和es7.md","raw":"---\ntitle: ES6和ES7\n---\n\n####  首先说下es6语法糖  \n1. let\n\n2. const\n\n3. 箭头函数\n\n4. 解构赋值\n\n5. promise\n\n\t\n\n\n\n","slug":"es6和es7","published":1,"date":"2018-04-16T11:31:44.000Z","updated":"2018-04-16T11:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos20004g4s6g1rsm7ax","content":"<h4 id=\"首先说下es6语法糖\"><a href=\"#首先说下es6语法糖\" class=\"headerlink\" title=\"首先说下es6语法糖\"></a>首先说下es6语法糖</h4><ol>\n<li><p>let</p>\n</li>\n<li><p>const</p>\n</li>\n<li><p>箭头函数</p>\n</li>\n<li><p>解构赋值</p>\n</li>\n<li><p>promise</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"首先说下es6语法糖\"><a href=\"#首先说下es6语法糖\" class=\"headerlink\" title=\"首先说下es6语法糖\"></a>首先说下es6语法糖</h4><ol>\n<li><p>let</p>\n</li>\n<li><p>const</p>\n</li>\n<li><p>箭头函数</p>\n</li>\n<li><p>解构赋值</p>\n</li>\n<li><p>promise</p>\n</li>\n</ol>\n"},{"title":"聊一聊git","_content":"\n###  1. Git push与pull的默认行为\n\n 一直以来对git push与git pull命令的默认行为感觉混乱，今天抽空总结下。\n\ngit push 通常在一个本地新建分支。git checkout -b develop,在develop分支commit了代码之后。 \n如果直接执行git push命令，develop分支将不会被push到远程仓库（但此时git push操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的push.default默认行为，下文将会逐一详解）\n\n###### 因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。\n\n当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行git push命令会有什么效果呢？\n\n如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:\n\n1.\tdevelop分支中本地新增的commit被push到远程仓库\n2.\tpush失败，并收到git如下的警告\n\t\n\t\tfatal: The current branch new has no upstream branch.  \n\t\tTo push the current branch and set the remote as upstream, use\n\n    \tgit push --set-upstream origin develop\n\n为什么git版本不同会有两种不同的push行为？\n\n因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为'matching'，2.0之后则被更改为了'simple'。\n\n我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config --global push.default 'option'改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。\n\npush.default 有以下几个可选值： \nnothing, current, upstream, simple, matching\n\n其用途分别为：\n\n\tnothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。\n\n\tcurrent - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。\n\n\tupstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。\n\n\tsimple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。\n\n\tmatching - push所有本地和远程两端都存在的同名分支。\n\n因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。\n\nupstream & downstream\n说到这里，需要解释一下git中的upstream到底是什么：\n\n\tgit中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。\n\n\t初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。\n\n注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。\n\n### 2. git pull\n\n弄清楚git push的默认行为后，再来看看git pull。\n\n当我们未指定当前分支的upstream时，通常git pull操作会得到如下的提示：\n\n\tThere is no tracking information for the current branch.  \n\tPlease specify which branch you want to merge with.  \n\tSee git-pull(1) for details\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=origin/<branch> new1\n\ngit pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。\n\n当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：\n\n\tgit branch --set-upstream-to=origin/<branch> develop  \n\t// 或者git push --set-upstream origin develop \n实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作\n\n\t[branch \"develop\"]\n    \tremote = origin\n    \tmerge = refs/heads/develop // [1]为什么不是refs/remotes/develop?\n或者通过command-line直接设置：\n\n\tgit config branch.develop.merge refs/heads/develop  \n这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去merge origin/develop；如果指定了upstream分支，则会忽略config中的merge默认配置。\n\n","source":"_posts/git默认行为.md","raw":"---\ntitle: 聊一聊git\n---\n\n###  1. Git push与pull的默认行为\n\n 一直以来对git push与git pull命令的默认行为感觉混乱，今天抽空总结下。\n\ngit push 通常在一个本地新建分支。git checkout -b develop,在develop分支commit了代码之后。 \n如果直接执行git push命令，develop分支将不会被push到远程仓库（但此时git push操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的push.default默认行为，下文将会逐一详解）\n\n###### 因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。\n\n当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行git push命令会有什么效果呢？\n\n如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:\n\n1.\tdevelop分支中本地新增的commit被push到远程仓库\n2.\tpush失败，并收到git如下的警告\n\t\n\t\tfatal: The current branch new has no upstream branch.  \n\t\tTo push the current branch and set the remote as upstream, use\n\n    \tgit push --set-upstream origin develop\n\n为什么git版本不同会有两种不同的push行为？\n\n因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为'matching'，2.0之后则被更改为了'simple'。\n\n我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config --global push.default 'option'改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。\n\npush.default 有以下几个可选值： \nnothing, current, upstream, simple, matching\n\n其用途分别为：\n\n\tnothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。\n\n\tcurrent - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。\n\n\tupstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。\n\n\tsimple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。\n\n\tmatching - push所有本地和远程两端都存在的同名分支。\n\n因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。\n\nupstream & downstream\n说到这里，需要解释一下git中的upstream到底是什么：\n\n\tgit中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。\n\n\t初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。\n\n注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。\n\n### 2. git pull\n\n弄清楚git push的默认行为后，再来看看git pull。\n\n当我们未指定当前分支的upstream时，通常git pull操作会得到如下的提示：\n\n\tThere is no tracking information for the current branch.  \n\tPlease specify which branch you want to merge with.  \n\tSee git-pull(1) for details\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=origin/<branch> new1\n\ngit pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。\n\n当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：\n\n\tgit branch --set-upstream-to=origin/<branch> develop  \n\t// 或者git push --set-upstream origin develop \n实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作\n\n\t[branch \"develop\"]\n    \tremote = origin\n    \tmerge = refs/heads/develop // [1]为什么不是refs/remotes/develop?\n或者通过command-line直接设置：\n\n\tgit config branch.develop.merge refs/heads/develop  \n这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去merge origin/develop；如果指定了upstream分支，则会忽略config中的merge默认配置。\n\n","slug":"git默认行为","published":1,"date":"2018-01-28T08:03:04.000Z","updated":"2018-01-28T08:03:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos30005g4s6w949f595","content":"<h3 id=\"1-Git-push与pull的默认行为\"><a href=\"#1-Git-push与pull的默认行为\" class=\"headerlink\" title=\"1. Git push与pull的默认行为\"></a>1. Git push与pull的默认行为</h3><p> 一直以来对git push与git pull命令的默认行为感觉混乱，今天抽空总结下。</p>\n<p>git push 通常在一个本地新建分支。git checkout -b develop,在develop分支commit了代码之后。<br>如果直接执行git push命令，develop分支将不会被push到远程仓库（但此时git push操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的push.default默认行为，下文将会逐一详解）</p>\n<h6 id=\"因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。\"><a href=\"#因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。\" class=\"headerlink\" title=\"因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。\"></a>因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。</h6><p>当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行git push命令会有什么效果呢？</p>\n<p>如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:</p>\n<ol>\n<li>develop分支中本地新增的commit被push到远程仓库</li>\n<li><p>push失败，并收到git如下的警告</p>\n<p>  fatal: The current branch new has no upstream branch.<br>  To push the current branch and set the remote as upstream, use</p>\n<p>  git push –set-upstream origin develop</p>\n</li>\n</ol>\n<p>为什么git版本不同会有两种不同的push行为？</p>\n<p>因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为’matching’，2.0之后则被更改为了’simple’。</p>\n<p>我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config –global push.default ‘option’改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。</p>\n<p>push.default 有以下几个可选值：<br>nothing, current, upstream, simple, matching</p>\n<p>其用途分别为：</p>\n<pre><code>nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。\n\ncurrent - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。\n\nupstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。\n\nsimple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。\n\nmatching - push所有本地和远程两端都存在的同名分支。\n</code></pre><p>因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。</p>\n<p>upstream &amp; downstream<br>说到这里，需要解释一下git中的upstream到底是什么：</p>\n<pre><code>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。\n\n初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。\n</code></pre><p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。</p>\n<h3 id=\"2-git-pull\"><a href=\"#2-git-pull\" class=\"headerlink\" title=\"2. git pull\"></a>2. git pull</h3><p>弄清楚git push的默认行为后，再来看看git pull。</p>\n<p>当我们未指定当前分支的upstream时，通常git pull操作会得到如下的提示：</p>\n<pre><code>There is no tracking information for the current branch.  \nPlease specify which branch you want to merge with.  \nSee git-pull(1) for details\n\ngit pull &lt;remote&gt; &lt;branch&gt;\n</code></pre><p>If you wish to set tracking information for this branch you can do so with:</p>\n<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; new1\n</code></pre><p>git pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p>\n<p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p>\n<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; develop  \n// 或者git push --set-upstream origin develop \n</code></pre><p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作</p>\n<pre><code>[branch &quot;develop&quot;]\n    remote = origin\n    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?\n</code></pre><p>或者通过command-line直接设置：</p>\n<pre><code>git config branch.develop.merge refs/heads/develop  \n</code></pre><p>这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去merge origin/develop；如果指定了upstream分支，则会忽略config中的merge默认配置。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-Git-push与pull的默认行为\"><a href=\"#1-Git-push与pull的默认行为\" class=\"headerlink\" title=\"1. Git push与pull的默认行为\"></a>1. Git push与pull的默认行为</h3><p> 一直以来对git push与git pull命令的默认行为感觉混乱，今天抽空总结下。</p>\n<p>git push 通常在一个本地新建分支。git checkout -b develop,在develop分支commit了代码之后。<br>如果直接执行git push命令，develop分支将不会被push到远程仓库（但此时git push操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的push.default默认行为，下文将会逐一详解）</p>\n<h6 id=\"因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。\"><a href=\"#因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。\" class=\"headerlink\" title=\"因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。\"></a>因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。</h6><p>当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行git push命令会有什么效果呢？</p>\n<p>如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:</p>\n<ol>\n<li>develop分支中本地新增的commit被push到远程仓库</li>\n<li><p>push失败，并收到git如下的警告</p>\n<p>  fatal: The current branch new has no upstream branch.<br>  To push the current branch and set the remote as upstream, use</p>\n<p>  git push –set-upstream origin develop</p>\n</li>\n</ol>\n<p>为什么git版本不同会有两种不同的push行为？</p>\n<p>因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为’matching’，2.0之后则被更改为了’simple’。</p>\n<p>我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config –global push.default ‘option’改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。</p>\n<p>push.default 有以下几个可选值：<br>nothing, current, upstream, simple, matching</p>\n<p>其用途分别为：</p>\n<pre><code>nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。\n\ncurrent - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。\n\nupstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。\n\nsimple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。\n\nmatching - push所有本地和远程两端都存在的同名分支。\n</code></pre><p>因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。</p>\n<p>upstream &amp; downstream<br>说到这里，需要解释一下git中的upstream到底是什么：</p>\n<pre><code>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。\n\n初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。\n</code></pre><p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。</p>\n<h3 id=\"2-git-pull\"><a href=\"#2-git-pull\" class=\"headerlink\" title=\"2. git pull\"></a>2. git pull</h3><p>弄清楚git push的默认行为后，再来看看git pull。</p>\n<p>当我们未指定当前分支的upstream时，通常git pull操作会得到如下的提示：</p>\n<pre><code>There is no tracking information for the current branch.  \nPlease specify which branch you want to merge with.  \nSee git-pull(1) for details\n\ngit pull &lt;remote&gt; &lt;branch&gt;\n</code></pre><p>If you wish to set tracking information for this branch you can do so with:</p>\n<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; new1\n</code></pre><p>git pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p>\n<p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p>\n<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; develop  \n// 或者git push --set-upstream origin develop \n</code></pre><p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作</p>\n<pre><code>[branch &quot;develop&quot;]\n    remote = origin\n    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?\n</code></pre><p>或者通过command-line直接设置：</p>\n<pre><code>git config branch.develop.merge refs/heads/develop  \n</code></pre><p>这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去merge origin/develop；如果指定了upstream分支，则会忽略config中的merge默认配置。</p>\n"},{"title":"Hello Hexo","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello Hexo\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-07-13T05:31:44.000Z","updated":"2017-07-13T05:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos40006g4s6fdl4vn47","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"flag","_content":"\n\n### 一、user-agent\n\n### 看一下Chrome的User-Agent\n\n### 这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\n* User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n* 看一下火狐的User-Agent\n可以看出来，该Firefox为Windows平台的发布版，内核为Firefox的自家内核Gecko\n* User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 \n* Firefox/30.0\n* 看一下Mac上的Safari\n* 看出来，兼容了Mozilla，为Mac系统的发布版，采用自家的Webkit内核(Apple)\n* User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) \n* \n* AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14\n\n* 最后是IE的User-Agent\n\n  看出来，兼容了Mozilla，采用兼容模式的IE10，采用自家的Trident内核\n* User-Agent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)\n * 模拟移动设备\n* 我们这里可以模拟一个移动设备来查看一下，显示效果，模拟设备，Galaxy Note II ，通过该设备向服务端发送请求\n\n* 请求标头，\n* User-Agent:Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\n\n二、host  主机域名，或ip地址\n\n\n三、accept\n\n四、refer\n\n五、gzip\n\n六、ttransfer-encoding\n\n\n\n","source":"_posts/http请求和响应.md","raw":"---\ntitle: flag\n---\n\n\n### 一、user-agent\n\n### 看一下Chrome的User-Agent\n\n### 这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\n* User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n* 看一下火狐的User-Agent\n可以看出来，该Firefox为Windows平台的发布版，内核为Firefox的自家内核Gecko\n* User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 \n* Firefox/30.0\n* 看一下Mac上的Safari\n* 看出来，兼容了Mozilla，为Mac系统的发布版，采用自家的Webkit内核(Apple)\n* User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) \n* \n* AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14\n\n* 最后是IE的User-Agent\n\n  看出来，兼容了Mozilla，采用兼容模式的IE10，采用自家的Trident内核\n* User-Agent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)\n * 模拟移动设备\n* 我们这里可以模拟一个移动设备来查看一下，显示效果，模拟设备，Galaxy Note II ，通过该设备向服务端发送请求\n\n* 请求标头，\n* User-Agent:Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\n\n二、host  主机域名，或ip地址\n\n\n三、accept\n\n四、refer\n\n五、gzip\n\n六、ttransfer-encoding\n\n\n\n","slug":"http请求和响应","published":1,"date":"2018-01-28T08:44:08.000Z","updated":"2018-01-28T08:44:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos60007g4s6vrrtahkw","content":"<h3 id=\"一、user-agent\"><a href=\"#一、user-agent\" class=\"headerlink\" title=\"一、user-agent\"></a>一、user-agent</h3><h3 id=\"看一下Chrome的User-Agent\"><a href=\"#看一下Chrome的User-Agent\" class=\"headerlink\" title=\"看一下Chrome的User-Agent\"></a>看一下Chrome的User-Agent</h3><h3 id=\"这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\"><a href=\"#这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\" class=\"headerlink\" title=\"这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\"></a>这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko</h3><ul>\n<li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</li>\n<li>看一下火狐的User-Agent<br>可以看出来，该Firefox为Windows平台的发布版，内核为Firefox的自家内核Gecko</li>\n<li>User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 </li>\n<li>Firefox/30.0</li>\n<li>看一下Mac上的Safari</li>\n<li>看出来，兼容了Mozilla，为Mac系统的发布版，采用自家的Webkit内核(Apple)</li>\n<li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) </li>\n<li></li>\n<li><p>AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14</p>\n</li>\n<li><p>最后是IE的User-Agent</p>\n<p>看出来，兼容了Mozilla，采用兼容模式的IE10，采用自家的Trident内核</p>\n</li>\n<li>User-Agent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)<ul>\n<li>模拟移动设备</li>\n</ul>\n</li>\n<li><p>我们这里可以模拟一个移动设备来查看一下，显示效果，模拟设备，Galaxy Note II ，通过该设备向服务端发送请求</p>\n</li>\n<li><p>请求标头，</p>\n</li>\n<li>User-Agent:Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>\n</ul>\n<p>二、host  主机域名，或ip地址</p>\n<p>三、accept</p>\n<p>四、refer</p>\n<p>五、gzip</p>\n<p>六、ttransfer-encoding</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、user-agent\"><a href=\"#一、user-agent\" class=\"headerlink\" title=\"一、user-agent\"></a>一、user-agent</h3><h3 id=\"看一下Chrome的User-Agent\"><a href=\"#看一下Chrome的User-Agent\" class=\"headerlink\" title=\"看一下Chrome的User-Agent\"></a>看一下Chrome的User-Agent</h3><h3 id=\"这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\"><a href=\"#这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\" class=\"headerlink\" title=\"这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko\"></a>这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko</h3><ul>\n<li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</li>\n<li>看一下火狐的User-Agent<br>可以看出来，该Firefox为Windows平台的发布版，内核为Firefox的自家内核Gecko</li>\n<li>User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 </li>\n<li>Firefox/30.0</li>\n<li>看一下Mac上的Safari</li>\n<li>看出来，兼容了Mozilla，为Mac系统的发布版，采用自家的Webkit内核(Apple)</li>\n<li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) </li>\n<li></li>\n<li><p>AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14</p>\n</li>\n<li><p>最后是IE的User-Agent</p>\n<p>看出来，兼容了Mozilla，采用兼容模式的IE10，采用自家的Trident内核</p>\n</li>\n<li>User-Agent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)<ul>\n<li>模拟移动设备</li>\n</ul>\n</li>\n<li><p>我们这里可以模拟一个移动设备来查看一下，显示效果，模拟设备，Galaxy Note II ，通过该设备向服务端发送请求</p>\n</li>\n<li><p>请求标头，</p>\n</li>\n<li>User-Agent:Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>\n</ul>\n<p>二、host  主机域名，或ip地址</p>\n<p>三、accept</p>\n<p>四、refer</p>\n<p>五、gzip</p>\n<p>六、ttransfer-encoding</p>\n"},{"title":"js的基本类型和引用类型","_content":"\n### 1、基本类型和引用类型的区别：\n\n1） 基本类型： \n\n2）  引用类型\n\n3） 两者区别\n\n4） 操作\n\n\t\t","source":"_posts/js的基本类型和引用类型.md","raw":"---\ntitle: js的基本类型和引用类型\n---\n\n### 1、基本类型和引用类型的区别：\n\n1） 基本类型： \n\n2）  引用类型\n\n3） 两者区别\n\n4） 操作\n\n\t\t","slug":"js的基本类型和引用类型","published":1,"date":"2018-07-16T05:40:00.000Z","updated":"2018-07-16T05:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos80008g4s6efujgwtq","content":"<h3 id=\"1、基本类型和引用类型的区别：\"><a href=\"#1、基本类型和引用类型的区别：\" class=\"headerlink\" title=\"1、基本类型和引用类型的区别：\"></a>1、基本类型和引用类型的区别：</h3><p>1） 基本类型： </p>\n<p>2）  引用类型</p>\n<p>3） 两者区别</p>\n<p>4） 操作</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、基本类型和引用类型的区别：\"><a href=\"#1、基本类型和引用类型的区别：\" class=\"headerlink\" title=\"1、基本类型和引用类型的区别：\"></a>1、基本类型和引用类型的区别：</h3><p>1） 基本类型： </p>\n<p>2）  引用类型</p>\n<p>3） 两者区别</p>\n<p>4） 操作</p>\n"},{"title":"js常用跨域方法","_content":"\n---\n","source":"_posts/promise的前世今生.md","raw":"---\ntitle: js常用跨域方法\n---\n\n---\n","slug":"promise的前世今生","published":1,"date":"2018-09-21T05:58:50.000Z","updated":"2018-09-21T05:58:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpos80009g4s6cwnld8w3","content":"<hr>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n"},{"title":"vue 单页面微信分享(hash模式)","_content":"\n vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。\n\n 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样当自己拼值时（如“？userId=123”）则需要取第二个问号后的值。之前无论如何都取不到自己拼在路径后的值，复制链接后才发现，微信默默地给加了一个问号和其他参数在其中。\n\n 坑点2： 如果在公众号中浏览一个页面，直接都是由路由跳转的。但浏览者从分享窗口进入后，再去浏览别的页面 在别的页面按照正常路由跳转到其他页面去分享时 始终是首次进入的页面。\n\n#### 以下有两种方法\n\t1： 使用微信自定义分享\n\t\t分享链接 通过获取url赋值\n\n\n\t2： vue单页面跳转的时候\n\n\t\t1） this.$router.push({ name: 'home', params: { userId: wise }})\n\t\t\n\t\t2） let url = `#/report/BWDaily?hash=${hash}&lang=${this.lang}&type=${this.type}`;\n\t\twindow.location.href= url;\n\n\t\n第一种方法： 实践不可用\n\t\n第二种方法： 实践可用。目前还没找到其根本原理。\n\t\n\n\n","source":"_posts/vue单页面分享.md","raw":"---\ntitle: vue 单页面微信分享(hash模式)\n---\n\n vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。\n\n 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样当自己拼值时（如“？userId=123”）则需要取第二个问号后的值。之前无论如何都取不到自己拼在路径后的值，复制链接后才发现，微信默默地给加了一个问号和其他参数在其中。\n\n 坑点2： 如果在公众号中浏览一个页面，直接都是由路由跳转的。但浏览者从分享窗口进入后，再去浏览别的页面 在别的页面按照正常路由跳转到其他页面去分享时 始终是首次进入的页面。\n\n#### 以下有两种方法\n\t1： 使用微信自定义分享\n\t\t分享链接 通过获取url赋值\n\n\n\t2： vue单页面跳转的时候\n\n\t\t1） this.$router.push({ name: 'home', params: { userId: wise }})\n\t\t\n\t\t2） let url = `#/report/BWDaily?hash=${hash}&lang=${this.lang}&type=${this.type}`;\n\t\twindow.location.href= url;\n\n\t\n第一种方法： 实践不可用\n\t\n第二种方法： 实践可用。目前还没找到其根本原理。\n\t\n\n\n","slug":"vue单页面分享","published":1,"date":"2018-05-16T07:32:00.000Z","updated":"2018-05-16T07:32:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposa000ag4s6skiwptz8","content":"<p> vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。</p>\n<p> 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样当自己拼值时（如“？userId=123”）则需要取第二个问号后的值。之前无论如何都取不到自己拼在路径后的值，复制链接后才发现，微信默默地给加了一个问号和其他参数在其中。</p>\n<p> 坑点2： 如果在公众号中浏览一个页面，直接都是由路由跳转的。但浏览者从分享窗口进入后，再去浏览别的页面 在别的页面按照正常路由跳转到其他页面去分享时 始终是首次进入的页面。</p>\n<h4 id=\"以下有两种方法\"><a href=\"#以下有两种方法\" class=\"headerlink\" title=\"以下有两种方法\"></a>以下有两种方法</h4><pre><code>1： 使用微信自定义分享\n    分享链接 通过获取url赋值\n\n\n2： vue单页面跳转的时候\n\n    1） this.$router.push({ name: &apos;home&apos;, params: { userId: wise }})\n\n    2） let url = `#/report/BWDaily?hash=${hash}&amp;lang=${this.lang}&amp;type=${this.type}`;\n    window.location.href= url;\n</code></pre><p>第一种方法： 实践不可用</p>\n<p>第二种方法： 实践可用。目前还没找到其根本原理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p> vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。</p>\n<p> 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样当自己拼值时（如“？userId=123”）则需要取第二个问号后的值。之前无论如何都取不到自己拼在路径后的值，复制链接后才发现，微信默默地给加了一个问号和其他参数在其中。</p>\n<p> 坑点2： 如果在公众号中浏览一个页面，直接都是由路由跳转的。但浏览者从分享窗口进入后，再去浏览别的页面 在别的页面按照正常路由跳转到其他页面去分享时 始终是首次进入的页面。</p>\n<h4 id=\"以下有两种方法\"><a href=\"#以下有两种方法\" class=\"headerlink\" title=\"以下有两种方法\"></a>以下有两种方法</h4><pre><code>1： 使用微信自定义分享\n    分享链接 通过获取url赋值\n\n\n2： vue单页面跳转的时候\n\n    1） this.$router.push({ name: &apos;home&apos;, params: { userId: wise }})\n\n    2） let url = `#/report/BWDaily?hash=${hash}&amp;lang=${this.lang}&amp;type=${this.type}`;\n    window.location.href= url;\n</code></pre><p>第一种方法： 实践不可用</p>\n<p>第二种方法： 实践可用。目前还没找到其根本原理。</p>\n"},{"title":"webpack4.5+vue 踩坑记录","_content":"\n### 1. 最新版本的webpack\n \t配置项： 最近在搭建新的框架，以前的项目webpack版本太低了，就准备升级一下。这一升级不得了，遇到了好多问题。\n\n\t\n### 2.vue\n\t目录项\t","source":"_posts/webpack4.5+vue.md","raw":"---\ntitle: webpack4.5+vue 踩坑记录\n---\n\n### 1. 最新版本的webpack\n \t配置项： 最近在搭建新的框架，以前的项目webpack版本太低了，就准备升级一下。这一升级不得了，遇到了好多问题。\n\n\t\n### 2.vue\n\t目录项\t","slug":"webpack4.5+vue","published":1,"date":"2018-04-16T11:31:44.000Z","updated":"2018-04-16T11:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposc000bg4s6iw7j4p0q","content":"<h3 id=\"1-最新版本的webpack\"><a href=\"#1-最新版本的webpack\" class=\"headerlink\" title=\"1. 最新版本的webpack\"></a>1. 最新版本的webpack</h3><pre><code>配置项： 最近在搭建新的框架，以前的项目webpack版本太低了，就准备升级一下。这一升级不得了，遇到了好多问题。\n</code></pre><h3 id=\"2-vue\"><a href=\"#2-vue\" class=\"headerlink\" title=\"2.vue\"></a>2.vue</h3><pre><code>目录项    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-最新版本的webpack\"><a href=\"#1-最新版本的webpack\" class=\"headerlink\" title=\"1. 最新版本的webpack\"></a>1. 最新版本的webpack</h3><pre><code>配置项： 最近在搭建新的框架，以前的项目webpack版本太低了，就准备升级一下。这一升级不得了，遇到了好多问题。\n</code></pre><h3 id=\"2-vue\"><a href=\"#2-vue\" class=\"headerlink\" title=\"2.vue\"></a>2.vue</h3><pre><code>目录项    \n</code></pre>"},{"title":"webstorm 打开没有项目目录","_content":"\n### 不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\n![](http://i.imgur.com/hdPspdH.png)\n\n### 连续出现好几次了。依旧记不住在此记录一下！\n\n#### 问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。\n\n\t解决办法：{\n\n\t1.关掉webstorm；\n\n\t2.删除.idea文件夹（如果隐藏，请设置显示隐藏文件夹）；\n\n\t3.重新新建项目；\n\n\t}\n\nOK！！！！","source":"_posts/webtorm目录消失.md","raw":"---\ntitle: webstorm 打开没有项目目录\n---\n\n### 不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\n![](http://i.imgur.com/hdPspdH.png)\n\n### 连续出现好几次了。依旧记不住在此记录一下！\n\n#### 问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。\n\n\t解决办法：{\n\n\t1.关掉webstorm；\n\n\t2.删除.idea文件夹（如果隐藏，请设置显示隐藏文件夹）；\n\n\t3.重新新建项目；\n\n\t}\n\nOK！！！！","slug":"webtorm目录消失","published":1,"date":"2017-12-26T03:50:42.000Z","updated":"2017-12-26T03:50:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposd000cg4s67kc26qpv","content":"<h3 id=\"不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\"><a href=\"#不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\" class=\"headerlink\" title=\"不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\"></a>不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：</h3><p><img src=\"http://i.imgur.com/hdPspdH.png\" alt=\"\"></p>\n<h3 id=\"连续出现好几次了。依旧记不住在此记录一下！\"><a href=\"#连续出现好几次了。依旧记不住在此记录一下！\" class=\"headerlink\" title=\"连续出现好几次了。依旧记不住在此记录一下！\"></a>连续出现好几次了。依旧记不住在此记录一下！</h3><h4 id=\"问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。\"><a href=\"#问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。\" class=\"headerlink\" title=\"问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。\"></a>问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。</h4><pre><code>解决办法：{\n\n1.关掉webstorm；\n\n2.删除.idea文件夹（如果隐藏，请设置显示隐藏文件夹）；\n\n3.重新新建项目；\n\n}\n</code></pre><p>OK！！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\"><a href=\"#不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\" class=\"headerlink\" title=\"不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：\"></a>不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：</h3><p><img src=\"http://i.imgur.com/hdPspdH.png\" alt=\"\"></p>\n<h3 id=\"连续出现好几次了。依旧记不住在此记录一下！\"><a href=\"#连续出现好几次了。依旧记不住在此记录一下！\" class=\"headerlink\" title=\"连续出现好几次了。依旧记不住在此记录一下！\"></a>连续出现好几次了。依旧记不住在此记录一下！</h3><h4 id=\"问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。\"><a href=\"#问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。\" class=\"headerlink\" title=\"问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。\"></a>问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。</h4><pre><code>解决办法：{\n\n1.关掉webstorm；\n\n2.删除.idea文件夹（如果隐藏，请设置显示隐藏文件夹）；\n\n3.重新新建项目；\n\n}\n</code></pre><p>OK！！！！</p>\n"},{"title":"css 圣杯布局和双飞翼布局","_content":"### 背景：\n\t按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、\n\t但是实现起来还是有区别的。\n\t\n\n### 1、 圣杯布局：\n\t\t\n\t圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了\n\t所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，\n\t它可以随着容器宽度的变化而自适应宽度。\n\n在这里，实现了左(100px) 右(100px) 宽度固定，中间自适应，container部分高度保持一致\n\t![](https://i.imgur.com/CzxbHrr.png)\n\n解释： \n\thtml代码中，container包括三部分内容，首先放置middle 然后是left和right()\n\n1. 顺序需要从middle到left ,right顺序固定，三者都需要float:left,（再加上position:relative相对布局后面会用到）\n2. middle需要设置宽度100%，占满\n3.\t此时middle占满了，要把left拉到最左边。margin-left: -100%;\n4.\t这个时候left过来了，但是会占用middle的内容，此时把container设置内边距 padding: 0 100px 0 100px;\n5.\tmiddle内容过来了，left也拉过来了，所以要还原，left要使用相对定位，left： -100px;同理right也要相对定位还原right: -100px;\n6.\t到这里大致就好了。 剩余就是高度的问题了。可以加上min-height使用。 \n\t\t\n好了，这里上代码：\n\t\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>css3</title>\n\t</head>\n\t<style>\n\n\t.container1 {\n        padding: 0 100px 0 100px;\n        min-height: 130px;\n    }\n    .middle {\n        float: left;\n        width: 100%;\n        background: #f00;\n        min-height: 130px;\n    }\n    .left {\n        float: left;\n        position: relative;\n        left: -100px;\n        background: #ccc;\n        width: 100px;\n        margin-left: -100%;\n        min-height: 130px;\n    }\n    .right {\n        float: left;\n        position: relative;\n        background: #588;\n        width: 100px;\n        margin-left: -100px;\n        right: -100px;\n        min-height: 130px;\n    }\n\t</style>\n\t<body>\n\t<div class=\"layout1\">\n        <div class=\"main\">main</div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n\n\t</body>\n\t</html>\n### 2、 双飞翼布局\n\t\n\t如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。这个布局的实现思路是，\n\t先把最重要的身体部分放好，然后再将翅膀移动到适当的地方.\n\n\t其实跟上边的圣杯布局差不多的，当然也可以改动一下（自己想想有哪些不同吧）\n\t恩，这里有一只鸟~\n\n\t左翅sub有200px,右翅extra..220px.. 身体main自适应未知\n\n![](https://i.imgur.com/KCw8DEO.png)\n\n1.html代码中，main要放最前边，sub  extra\n\n2.将main  sub  extra 都float:left\n\n3.将main占满 width:100%\n\n4.此时main占满了，所以要把sub拉到最左边，使用margin-left:-100%  同理 extra使用margin-left:-220px\n\n（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）\n\n5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。\n\n给main增加一个内层div-- main-inner, 然后margin:0 220px 0 200px\n\n6.main正确展示\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>css3</title>\n\t</head>\n\t<style>\n\n\t.container2 {\n        /*padding: 0 100px 0 100px;*/\n    }\n    .main {\n        float: left;\n        width: 100%;\n        min-height: 130px;\n    }\n    .main-middle {\n        margin: 0 100px 0 100px;\n        background: #f00;\n    }\n    .left {\n        float: left;\n        background: #ccc;\n        width: 100px;\n        margin-left: -100%;\n        min-height: 130px;\n    }\n    .right {\n        float: left;\n        background: #588;\n        width: 100px;\n        margin-left: -100px;\n        min-height: 130px;\n    }\n\t</style>\n\t<body>\n\t<div class=\"container2\">\n        <div class=\"main\">\n            <div class=\"main-middle\">main---\n\t\t\t</div>\n        </div>\n        <div class=\"left\">left--- </div>\n        <div class=\"right\">right--- </div>\n    </div>\n\n\t</body>\n\t</html>\n\n#### 完结！\n\t\n\t\t\n\n\t","source":"_posts/圣杯布局和双飞翼布局.md","raw":"---\ntitle: css 圣杯布局和双飞翼布局\n---\n### 背景：\n\t按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、\n\t但是实现起来还是有区别的。\n\t\n\n### 1、 圣杯布局：\n\t\t\n\t圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了\n\t所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，\n\t它可以随着容器宽度的变化而自适应宽度。\n\n在这里，实现了左(100px) 右(100px) 宽度固定，中间自适应，container部分高度保持一致\n\t![](https://i.imgur.com/CzxbHrr.png)\n\n解释： \n\thtml代码中，container包括三部分内容，首先放置middle 然后是left和right()\n\n1. 顺序需要从middle到left ,right顺序固定，三者都需要float:left,（再加上position:relative相对布局后面会用到）\n2. middle需要设置宽度100%，占满\n3.\t此时middle占满了，要把left拉到最左边。margin-left: -100%;\n4.\t这个时候left过来了，但是会占用middle的内容，此时把container设置内边距 padding: 0 100px 0 100px;\n5.\tmiddle内容过来了，left也拉过来了，所以要还原，left要使用相对定位，left： -100px;同理right也要相对定位还原right: -100px;\n6.\t到这里大致就好了。 剩余就是高度的问题了。可以加上min-height使用。 \n\t\t\n好了，这里上代码：\n\t\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>css3</title>\n\t</head>\n\t<style>\n\n\t.container1 {\n        padding: 0 100px 0 100px;\n        min-height: 130px;\n    }\n    .middle {\n        float: left;\n        width: 100%;\n        background: #f00;\n        min-height: 130px;\n    }\n    .left {\n        float: left;\n        position: relative;\n        left: -100px;\n        background: #ccc;\n        width: 100px;\n        margin-left: -100%;\n        min-height: 130px;\n    }\n    .right {\n        float: left;\n        position: relative;\n        background: #588;\n        width: 100px;\n        margin-left: -100px;\n        right: -100px;\n        min-height: 130px;\n    }\n\t</style>\n\t<body>\n\t<div class=\"layout1\">\n        <div class=\"main\">main</div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n\n\t</body>\n\t</html>\n### 2、 双飞翼布局\n\t\n\t如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。这个布局的实现思路是，\n\t先把最重要的身体部分放好，然后再将翅膀移动到适当的地方.\n\n\t其实跟上边的圣杯布局差不多的，当然也可以改动一下（自己想想有哪些不同吧）\n\t恩，这里有一只鸟~\n\n\t左翅sub有200px,右翅extra..220px.. 身体main自适应未知\n\n![](https://i.imgur.com/KCw8DEO.png)\n\n1.html代码中，main要放最前边，sub  extra\n\n2.将main  sub  extra 都float:left\n\n3.将main占满 width:100%\n\n4.此时main占满了，所以要把sub拉到最左边，使用margin-left:-100%  同理 extra使用margin-left:-220px\n\n（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）\n\n5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。\n\n给main增加一个内层div-- main-inner, 然后margin:0 220px 0 200px\n\n6.main正确展示\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>css3</title>\n\t</head>\n\t<style>\n\n\t.container2 {\n        /*padding: 0 100px 0 100px;*/\n    }\n    .main {\n        float: left;\n        width: 100%;\n        min-height: 130px;\n    }\n    .main-middle {\n        margin: 0 100px 0 100px;\n        background: #f00;\n    }\n    .left {\n        float: left;\n        background: #ccc;\n        width: 100px;\n        margin-left: -100%;\n        min-height: 130px;\n    }\n    .right {\n        float: left;\n        background: #588;\n        width: 100px;\n        margin-left: -100px;\n        min-height: 130px;\n    }\n\t</style>\n\t<body>\n\t<div class=\"container2\">\n        <div class=\"main\">\n            <div class=\"main-middle\">main---\n\t\t\t</div>\n        </div>\n        <div class=\"left\">left--- </div>\n        <div class=\"right\">right--- </div>\n    </div>\n\n\t</body>\n\t</html>\n\n#### 完结！\n\t\n\t\t\n\n\t","slug":"圣杯布局和双飞翼布局","published":1,"date":"2018-06-15T10:17:28.000Z","updated":"2018-06-15T10:17:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmpose000dg4s66g7w0fy6","content":"<h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><pre><code>按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、\n但是实现起来还是有区别的。\n</code></pre><h3 id=\"1、-圣杯布局：\"><a href=\"#1、-圣杯布局：\" class=\"headerlink\" title=\"1、 圣杯布局：\"></a>1、 圣杯布局：</h3><pre><code>圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了\n所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，\n它可以随着容器宽度的变化而自适应宽度。\n</code></pre><p>在这里，实现了左(100px) 右(100px) 宽度固定，中间自适应，container部分高度保持一致<br>    <img src=\"https://i.imgur.com/CzxbHrr.png\" alt=\"\"></p>\n<p>解释：<br>    html代码中，container包括三部分内容，首先放置middle 然后是left和right()</p>\n<ol>\n<li>顺序需要从middle到left ,right顺序固定，三者都需要float:left,（再加上position:relative相对布局后面会用到）</li>\n<li>middle需要设置宽度100%，占满</li>\n<li>此时middle占满了，要把left拉到最左边。margin-left: -100%;</li>\n<li>这个时候left过来了，但是会占用middle的内容，此时把container设置内边距 padding: 0 100px 0 100px;</li>\n<li>middle内容过来了，left也拉过来了，所以要还原，left要使用相对定位，left： -100px;同理right也要相对定位还原right: -100px;</li>\n<li>到这里大致就好了。 剩余就是高度的问题了。可以加上min-height使用。 </li>\n</ol>\n<p>好了，这里上代码：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;css3&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n\n.container1 {\n    padding: 0 100px 0 100px;\n    min-height: 130px;\n}\n.middle {\n    float: left;\n    width: 100%;\n    background: #f00;\n    min-height: 130px;\n}\n.left {\n    float: left;\n    position: relative;\n    left: -100px;\n    background: #ccc;\n    width: 100px;\n    margin-left: -100%;\n    min-height: 130px;\n}\n.right {\n    float: left;\n    position: relative;\n    background: #588;\n    width: 100px;\n    margin-left: -100px;\n    right: -100px;\n    min-height: 130px;\n}\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div class=&quot;layout1&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"2、-双飞翼布局\"><a href=\"#2、-双飞翼布局\" class=\"headerlink\" title=\"2、 双飞翼布局\"></a>2、 双飞翼布局</h3><pre><code>如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。这个布局的实现思路是，\n先把最重要的身体部分放好，然后再将翅膀移动到适当的地方.\n\n其实跟上边的圣杯布局差不多的，当然也可以改动一下（自己想想有哪些不同吧）\n恩，这里有一只鸟~\n\n左翅sub有200px,右翅extra..220px.. 身体main自适应未知\n</code></pre><p><img src=\"https://i.imgur.com/KCw8DEO.png\" alt=\"\"></p>\n<p>1.html代码中，main要放最前边，sub  extra</p>\n<p>2.将main  sub  extra 都float:left</p>\n<p>3.将main占满 width:100%</p>\n<p>4.此时main占满了，所以要把sub拉到最左边，使用margin-left:-100%  同理 extra使用margin-left:-220px</p>\n<p>（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）</p>\n<p>5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。</p>\n<p>给main增加一个内层div– main-inner, 然后margin:0 220px 0 200px</p>\n<p>6.main正确展示</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;css3&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n\n.container2 {\n    /*padding: 0 100px 0 100px;*/\n}\n.main {\n    float: left;\n    width: 100%;\n    min-height: 130px;\n}\n.main-middle {\n    margin: 0 100px 0 100px;\n    background: #f00;\n}\n.left {\n    float: left;\n    background: #ccc;\n    width: 100px;\n    margin-left: -100%;\n    min-height: 130px;\n}\n.right {\n    float: left;\n    background: #588;\n    width: 100px;\n    margin-left: -100px;\n    min-height: 130px;\n}\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div class=&quot;container2&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;\n        &lt;div class=&quot;main-middle&quot;&gt;main---\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;left--- &lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;right--- &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"完结！\"><a href=\"#完结！\" class=\"headerlink\" title=\"完结！\"></a>完结！</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><pre><code>按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、\n但是实现起来还是有区别的。\n</code></pre><h3 id=\"1、-圣杯布局：\"><a href=\"#1、-圣杯布局：\" class=\"headerlink\" title=\"1、 圣杯布局：\"></a>1、 圣杯布局：</h3><pre><code>圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了\n所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，\n它可以随着容器宽度的变化而自适应宽度。\n</code></pre><p>在这里，实现了左(100px) 右(100px) 宽度固定，中间自适应，container部分高度保持一致<br>    <img src=\"https://i.imgur.com/CzxbHrr.png\" alt=\"\"></p>\n<p>解释：<br>    html代码中，container包括三部分内容，首先放置middle 然后是left和right()</p>\n<ol>\n<li>顺序需要从middle到left ,right顺序固定，三者都需要float:left,（再加上position:relative相对布局后面会用到）</li>\n<li>middle需要设置宽度100%，占满</li>\n<li>此时middle占满了，要把left拉到最左边。margin-left: -100%;</li>\n<li>这个时候left过来了，但是会占用middle的内容，此时把container设置内边距 padding: 0 100px 0 100px;</li>\n<li>middle内容过来了，left也拉过来了，所以要还原，left要使用相对定位，left： -100px;同理right也要相对定位还原right: -100px;</li>\n<li>到这里大致就好了。 剩余就是高度的问题了。可以加上min-height使用。 </li>\n</ol>\n<p>好了，这里上代码：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;css3&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n\n.container1 {\n    padding: 0 100px 0 100px;\n    min-height: 130px;\n}\n.middle {\n    float: left;\n    width: 100%;\n    background: #f00;\n    min-height: 130px;\n}\n.left {\n    float: left;\n    position: relative;\n    left: -100px;\n    background: #ccc;\n    width: 100px;\n    margin-left: -100%;\n    min-height: 130px;\n}\n.right {\n    float: left;\n    position: relative;\n    background: #588;\n    width: 100px;\n    margin-left: -100px;\n    right: -100px;\n    min-height: 130px;\n}\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div class=&quot;layout1&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"2、-双飞翼布局\"><a href=\"#2、-双飞翼布局\" class=\"headerlink\" title=\"2、 双飞翼布局\"></a>2、 双飞翼布局</h3><pre><code>如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。这个布局的实现思路是，\n先把最重要的身体部分放好，然后再将翅膀移动到适当的地方.\n\n其实跟上边的圣杯布局差不多的，当然也可以改动一下（自己想想有哪些不同吧）\n恩，这里有一只鸟~\n\n左翅sub有200px,右翅extra..220px.. 身体main自适应未知\n</code></pre><p><img src=\"https://i.imgur.com/KCw8DEO.png\" alt=\"\"></p>\n<p>1.html代码中，main要放最前边，sub  extra</p>\n<p>2.将main  sub  extra 都float:left</p>\n<p>3.将main占满 width:100%</p>\n<p>4.此时main占满了，所以要把sub拉到最左边，使用margin-left:-100%  同理 extra使用margin-left:-220px</p>\n<p>（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）</p>\n<p>5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。</p>\n<p>给main增加一个内层div– main-inner, 然后margin:0 220px 0 200px</p>\n<p>6.main正确展示</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;css3&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n\n.container2 {\n    /*padding: 0 100px 0 100px;*/\n}\n.main {\n    float: left;\n    width: 100%;\n    min-height: 130px;\n}\n.main-middle {\n    margin: 0 100px 0 100px;\n    background: #f00;\n}\n.left {\n    float: left;\n    background: #ccc;\n    width: 100px;\n    margin-left: -100%;\n    min-height: 130px;\n}\n.right {\n    float: left;\n    background: #588;\n    width: 100px;\n    margin-left: -100px;\n    min-height: 130px;\n}\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div class=&quot;container2&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;\n        &lt;div class=&quot;main-middle&quot;&gt;main---\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;left--- &lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;right--- &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"完结！\"><a href=\"#完结！\" class=\"headerlink\" title=\"完结！\"></a>完结！</h4>"},{"title":"text","_content":"","source":"_posts/多终端.md","raw":"---\ntitle: text\n---\n","slug":"多终端","published":1,"date":"2017-12-26T03:50:42.000Z","updated":"2017-12-26T03:50:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposg000eg4s67ne42pd6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"浅谈typeof 和instanceof的区别","_content":"\n####  先介绍下js的基本类型和引用类型\n基本类型： Null,Undefined,Boolean ,Number和String\n\n引用类型：  Object、Array、RegExp、Date、Function\n\t\t\n\n#### typeof和instanceof\n  \n相同点： 都是用来判断一个变量是什么类型的。\n\n区别：\ntypeof是一元运算放在一个运算数之前可以是任意类型。\n\ntypeof 一般只能返回以下几种类型：Number,String,Boolean,Function, Object,Null,Undefined. Symbol \n\n\t我们可以使用typeof 来判断一个变量是否存在，如if(typeof a !== 'undefined'){alert(\"a\")}; \n\t最好不要使用if(a) 如果a不存在会报错。\n\t对于array和null等特殊对象使用typeof 都会返回object。\n\n判断一个变量的类型常常会用typeof，在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象它都会返回object。\n\n\tlet s = new String('abc');\n\ttypeof s === 'object'// true\n\ts instanceof String // true\n\n此时就需要用到instanceof 来判断。\n\n#### typeof的原理：\n我们可以想想js在底层是怎么存储数据的类型信息呢。js的变量的底层实现。\n\n其实：js在底层存储变量的时候。会在变量的机器码的低位1-3位存储其类型信息。\n\n\t000 对象\n\t010 浮点数\n\t100 字符串\n\t110 布尔\n\t1 整数\n\n但是对与null和undefined来说，这两个值的存储信息是有点特殊的。\n\t\n\tnull 所有机器码均为0\n\tundefined: 用-2^30 整数来表示。\n\n\n所以判断 typeof null的时候就出现问题了。因为null的机器码，因此就被当作了对象来对待。\n\n如果用instanceof 来判断的话。\n  \n\tnull instanceof null   //TypeError: Right-hand side of 'instanceof' is not an object\n\n还有一个判断类型的方法\n\n\tObject.prototype.toString.call(1) //\"[object, Number]\"\n\t其他类型以此类推\n\n\n\n#### instanceof的原理 \n\n下面介绍 instanceof  \ninstanceof 主要是判断一个实例是否属于某种类型。\n\n1.\n\t\n\tlet person  = function(){}\n\tlet nichol = new person();\n\tnichol instanceof person  //true\n2.\n\t\n\tlet person = function(){}\n\tlet person_per = function(){}\n\tperson_per.prototype = new peroson()\n\n\tlet nichol = new  person_per();\n\tnichol instanceof person; //true\n\tnichol instanceof person_per ;  //true \n\n这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下\n\n\tfunction new_instance_of(leftVaule, rightVaule) {\n\t\tlet rightProto = rightVaule.prototype; // 取右表达式的 prototype 值\n\t\tleftVaule = leftVaule.__proto__; // 取左表达式的__proto__值\n\t\twhile (true) {\n\t\t\tif (leftVaule === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (leftVaule === rightProto) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tleftVaule = leftVaule.__proto__\n\t\t}\n\t}\n\ninstanceof的实现原理大致就是只要右侧变量的prototype在左侧变量的原型链上即可。\n\n因此 instanceof在查找的过程中会遍历左侧的原型链，直到找到右侧变量的prototype,如果查找失败就会返回false,告诉我们左侧变量并非是右侧变量的实例、\n\n举个栗子：\n\t\n\tfunction foo(){\n\n\t}\n\tfunction instanceof Object //true\n\tfunction instanceof function //true\n\tObject instanceof Object //true\n\tfoo instanceof Object //true\n\tfoo instanceof foo //false\n\tfoo instanceof function //true\n\n下面我们来一一解释其结果为什么这样：\n这就涉及到javascript的继承原理\n关于原型继承的原理，我简单用一张图来表示\n![](https://i.imgur.com/X44Z17j.png)\n\n每个javascript对象都有一个隐式的_proto_ 原型属性。而显示属性是prototype, 只有object.prototype._proto_属性在未修改的情况下为null值。\n\n根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。\n\n1. object instanceof object\n\n \t由图可知，Object的prototype属性是Object.prototype,而由于Object本身是一个函数，由function所创建。\n\n \t所有Object._proto_的值是Function.prototype,而Function.prototype的_proto_属性是Object.prorotype，\n\n \t所有可能判断出 object instanceof object 的结果是true.\n\n\t\tleftValue = Object._proto_ = Function.prototype;\n\t\t\n\t\trightValue = Object.prototype\n\t\t\n\t\t//第一次判断\n\t\t\n\t\tleftValue != rightValue\n\t\t\n\t\tleftValue = Function.prototype._proto_ = Object._prototype\n\t\t\n\t\t//第二次判断\n\t\t\n\t\tleftValue = rightValue\n\nFunction instanceof Function和 Function instanceof Object的运行过程与Object instanceof Object类似。故不再详说\n\n2. Foo instanceof Foo\n\n\tFoo函数的prototype 属性是Foo.prototype, 而foo的_proto_属性是Function.prototype,\n\n\t由图可知，Foo的原型链上并没有Foo.prototype,因此Foo instanceof Foo也就返回false;\n\n\t我们用代码简单的表示一下：\n\n\t\tleftValue = Foo, rightValue = Foo;\n\t\tleftValue = Foo._proto = function.prototype;\n\t\trightValue = Foo.prototype;\n\t\t//第一次判断\n\t\tleftValue != rightValue;\n\t\tleftValue = Function.prototype._proto_ = Object.prototype\n\t\t//第二次判断\n\t\tleftValue != rightValue;\n\t\tleftValue = Object.prototype　＝null\n\t\t//第三次判断\n\t\tleftValue = null;\n\n3. Foo instanceof Object\n\n\t\tleftValue = Foo, rightValue = Object\n\n\t\tleftValue = Foo.__proto__ = Function.prototype\n\t\trightValue = Object.prototype\n\t\t// 第一次判断\n\t\tleftValue != rightValue\n\t\tleftValue = Function.prototype.__proto__ = Object.prototype\n\t\t// 第二次判断\n\t\tleftValue === rightValue\n\t\t// 返回 true\n\n4. Foo instanceof Function\n\n\t\tleftValue = Foo, rightValue = Function\n\t\tleftValue = Foo.__proto__ = Function.prototype\n\t\trightValue = Function.prototype\n\t\t// 第一次判断\n\t\tleftValue === rightValue\n\t\t// 返回 true\n\n\n总结来说：\n\n我们使用typeof　来判断基本类型是OK的。不过需要注意当用typeof 来判断null类型的问题。如果想要判断一个对象的具体类型可以用instanceof 。但是instanceof　可能也判断不准确，例如一个数组，可以被instanceof　判断为Object。\n\n所以我们想要比较准确的判断一个数的类型时，可以用Object.prototype.toString.tocall 方法。","source":"_posts/浅谈 typeof 和 instanceof的区别.md","raw":"---\ntitle: 浅谈typeof 和instanceof的区别\n---\n\n####  先介绍下js的基本类型和引用类型\n基本类型： Null,Undefined,Boolean ,Number和String\n\n引用类型：  Object、Array、RegExp、Date、Function\n\t\t\n\n#### typeof和instanceof\n  \n相同点： 都是用来判断一个变量是什么类型的。\n\n区别：\ntypeof是一元运算放在一个运算数之前可以是任意类型。\n\ntypeof 一般只能返回以下几种类型：Number,String,Boolean,Function, Object,Null,Undefined. Symbol \n\n\t我们可以使用typeof 来判断一个变量是否存在，如if(typeof a !== 'undefined'){alert(\"a\")}; \n\t最好不要使用if(a) 如果a不存在会报错。\n\t对于array和null等特殊对象使用typeof 都会返回object。\n\n判断一个变量的类型常常会用typeof，在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象它都会返回object。\n\n\tlet s = new String('abc');\n\ttypeof s === 'object'// true\n\ts instanceof String // true\n\n此时就需要用到instanceof 来判断。\n\n#### typeof的原理：\n我们可以想想js在底层是怎么存储数据的类型信息呢。js的变量的底层实现。\n\n其实：js在底层存储变量的时候。会在变量的机器码的低位1-3位存储其类型信息。\n\n\t000 对象\n\t010 浮点数\n\t100 字符串\n\t110 布尔\n\t1 整数\n\n但是对与null和undefined来说，这两个值的存储信息是有点特殊的。\n\t\n\tnull 所有机器码均为0\n\tundefined: 用-2^30 整数来表示。\n\n\n所以判断 typeof null的时候就出现问题了。因为null的机器码，因此就被当作了对象来对待。\n\n如果用instanceof 来判断的话。\n  \n\tnull instanceof null   //TypeError: Right-hand side of 'instanceof' is not an object\n\n还有一个判断类型的方法\n\n\tObject.prototype.toString.call(1) //\"[object, Number]\"\n\t其他类型以此类推\n\n\n\n#### instanceof的原理 \n\n下面介绍 instanceof  \ninstanceof 主要是判断一个实例是否属于某种类型。\n\n1.\n\t\n\tlet person  = function(){}\n\tlet nichol = new person();\n\tnichol instanceof person  //true\n2.\n\t\n\tlet person = function(){}\n\tlet person_per = function(){}\n\tperson_per.prototype = new peroson()\n\n\tlet nichol = new  person_per();\n\tnichol instanceof person; //true\n\tnichol instanceof person_per ;  //true \n\n这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下\n\n\tfunction new_instance_of(leftVaule, rightVaule) {\n\t\tlet rightProto = rightVaule.prototype; // 取右表达式的 prototype 值\n\t\tleftVaule = leftVaule.__proto__; // 取左表达式的__proto__值\n\t\twhile (true) {\n\t\t\tif (leftVaule === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (leftVaule === rightProto) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tleftVaule = leftVaule.__proto__\n\t\t}\n\t}\n\ninstanceof的实现原理大致就是只要右侧变量的prototype在左侧变量的原型链上即可。\n\n因此 instanceof在查找的过程中会遍历左侧的原型链，直到找到右侧变量的prototype,如果查找失败就会返回false,告诉我们左侧变量并非是右侧变量的实例、\n\n举个栗子：\n\t\n\tfunction foo(){\n\n\t}\n\tfunction instanceof Object //true\n\tfunction instanceof function //true\n\tObject instanceof Object //true\n\tfoo instanceof Object //true\n\tfoo instanceof foo //false\n\tfoo instanceof function //true\n\n下面我们来一一解释其结果为什么这样：\n这就涉及到javascript的继承原理\n关于原型继承的原理，我简单用一张图来表示\n![](https://i.imgur.com/X44Z17j.png)\n\n每个javascript对象都有一个隐式的_proto_ 原型属性。而显示属性是prototype, 只有object.prototype._proto_属性在未修改的情况下为null值。\n\n根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。\n\n1. object instanceof object\n\n \t由图可知，Object的prototype属性是Object.prototype,而由于Object本身是一个函数，由function所创建。\n\n \t所有Object._proto_的值是Function.prototype,而Function.prototype的_proto_属性是Object.prorotype，\n\n \t所有可能判断出 object instanceof object 的结果是true.\n\n\t\tleftValue = Object._proto_ = Function.prototype;\n\t\t\n\t\trightValue = Object.prototype\n\t\t\n\t\t//第一次判断\n\t\t\n\t\tleftValue != rightValue\n\t\t\n\t\tleftValue = Function.prototype._proto_ = Object._prototype\n\t\t\n\t\t//第二次判断\n\t\t\n\t\tleftValue = rightValue\n\nFunction instanceof Function和 Function instanceof Object的运行过程与Object instanceof Object类似。故不再详说\n\n2. Foo instanceof Foo\n\n\tFoo函数的prototype 属性是Foo.prototype, 而foo的_proto_属性是Function.prototype,\n\n\t由图可知，Foo的原型链上并没有Foo.prototype,因此Foo instanceof Foo也就返回false;\n\n\t我们用代码简单的表示一下：\n\n\t\tleftValue = Foo, rightValue = Foo;\n\t\tleftValue = Foo._proto = function.prototype;\n\t\trightValue = Foo.prototype;\n\t\t//第一次判断\n\t\tleftValue != rightValue;\n\t\tleftValue = Function.prototype._proto_ = Object.prototype\n\t\t//第二次判断\n\t\tleftValue != rightValue;\n\t\tleftValue = Object.prototype　＝null\n\t\t//第三次判断\n\t\tleftValue = null;\n\n3. Foo instanceof Object\n\n\t\tleftValue = Foo, rightValue = Object\n\n\t\tleftValue = Foo.__proto__ = Function.prototype\n\t\trightValue = Object.prototype\n\t\t// 第一次判断\n\t\tleftValue != rightValue\n\t\tleftValue = Function.prototype.__proto__ = Object.prototype\n\t\t// 第二次判断\n\t\tleftValue === rightValue\n\t\t// 返回 true\n\n4. Foo instanceof Function\n\n\t\tleftValue = Foo, rightValue = Function\n\t\tleftValue = Foo.__proto__ = Function.prototype\n\t\trightValue = Function.prototype\n\t\t// 第一次判断\n\t\tleftValue === rightValue\n\t\t// 返回 true\n\n\n总结来说：\n\n我们使用typeof　来判断基本类型是OK的。不过需要注意当用typeof 来判断null类型的问题。如果想要判断一个对象的具体类型可以用instanceof 。但是instanceof　可能也判断不准确，例如一个数组，可以被instanceof　判断为Object。\n\n所以我们想要比较准确的判断一个数的类型时，可以用Object.prototype.toString.tocall 方法。","slug":"浅谈 typeof 和 instanceof的区别","published":1,"date":"2018-06-11T10:02:18.000Z","updated":"2018-06-11T10:02:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposh000fg4s6q1ewkiyh","content":"<h4 id=\"先介绍下js的基本类型和引用类型\"><a href=\"#先介绍下js的基本类型和引用类型\" class=\"headerlink\" title=\"先介绍下js的基本类型和引用类型\"></a>先介绍下js的基本类型和引用类型</h4><p>基本类型： Null,Undefined,Boolean ,Number和String</p>\n<p>引用类型：  Object、Array、RegExp、Date、Function</p>\n<h4 id=\"typeof和instanceof\"><a href=\"#typeof和instanceof\" class=\"headerlink\" title=\"typeof和instanceof\"></a>typeof和instanceof</h4><p>相同点： 都是用来判断一个变量是什么类型的。</p>\n<p>区别：<br>typeof是一元运算放在一个运算数之前可以是任意类型。</p>\n<p>typeof 一般只能返回以下几种类型：Number,String,Boolean,Function, Object,Null,Undefined. Symbol </p>\n<pre><code>我们可以使用typeof 来判断一个变量是否存在，如if(typeof a !== &apos;undefined&apos;){alert(&quot;a&quot;)}; \n最好不要使用if(a) 如果a不存在会报错。\n对于array和null等特殊对象使用typeof 都会返回object。\n</code></pre><p>判断一个变量的类型常常会用typeof，在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象它都会返回object。</p>\n<pre><code>let s = new String(&apos;abc&apos;);\ntypeof s === &apos;object&apos;// true\ns instanceof String // true\n</code></pre><p>此时就需要用到instanceof 来判断。</p>\n<h4 id=\"typeof的原理：\"><a href=\"#typeof的原理：\" class=\"headerlink\" title=\"typeof的原理：\"></a>typeof的原理：</h4><p>我们可以想想js在底层是怎么存储数据的类型信息呢。js的变量的底层实现。</p>\n<p>其实：js在底层存储变量的时候。会在变量的机器码的低位1-3位存储其类型信息。</p>\n<pre><code>000 对象\n010 浮点数\n100 字符串\n110 布尔\n1 整数\n</code></pre><p>但是对与null和undefined来说，这两个值的存储信息是有点特殊的。</p>\n<pre><code>null 所有机器码均为0\nundefined: 用-2^30 整数来表示。\n</code></pre><p>所以判断 typeof null的时候就出现问题了。因为null的机器码，因此就被当作了对象来对待。</p>\n<p>如果用instanceof 来判断的话。</p>\n<pre><code>null instanceof null   //TypeError: Right-hand side of &apos;instanceof&apos; is not an object\n</code></pre><p>还有一个判断类型的方法</p>\n<pre><code>Object.prototype.toString.call(1) //&quot;[object, Number]&quot;\n其他类型以此类推\n</code></pre><h4 id=\"instanceof的原理\"><a href=\"#instanceof的原理\" class=\"headerlink\" title=\"instanceof的原理\"></a>instanceof的原理</h4><p>下面介绍 instanceof<br>instanceof 主要是判断一个实例是否属于某种类型。</p>\n<p>1.</p>\n<pre><code>let person  = function(){}\nlet nichol = new person();\nnichol instanceof person  //true\n</code></pre><p>2.</p>\n<pre><code>let person = function(){}\nlet person_per = function(){}\nperson_per.prototype = new peroson()\n\nlet nichol = new  person_per();\nnichol instanceof person; //true\nnichol instanceof person_per ;  //true \n</code></pre><p>这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p>\n<pre><code>function new_instance_of(leftVaule, rightVaule) {\n    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值\n    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值\n    while (true) {\n        if (leftVaule === null) {\n            return false;\n        }\n        if (leftVaule === rightProto) {\n            return true;\n        }\n        leftVaule = leftVaule.__proto__\n    }\n}\n</code></pre><p>instanceof的实现原理大致就是只要右侧变量的prototype在左侧变量的原型链上即可。</p>\n<p>因此 instanceof在查找的过程中会遍历左侧的原型链，直到找到右侧变量的prototype,如果查找失败就会返回false,告诉我们左侧变量并非是右侧变量的实例、</p>\n<p>举个栗子：</p>\n<pre><code>function foo(){\n\n}\nfunction instanceof Object //true\nfunction instanceof function //true\nObject instanceof Object //true\nfoo instanceof Object //true\nfoo instanceof foo //false\nfoo instanceof function //true\n</code></pre><p>下面我们来一一解释其结果为什么这样：<br>这就涉及到javascript的继承原理<br>关于原型继承的原理，我简单用一张图来表示<br><img src=\"https://i.imgur.com/X44Z17j.png\" alt=\"\"></p>\n<p>每个javascript对象都有一个隐式的<em>proto</em> 原型属性。而显示属性是prototype, 只有object.prototype.<em>proto</em>属性在未修改的情况下为null值。</p>\n<p>根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。</p>\n<ol>\n<li><p>object instanceof object</p>\n<p>  由图可知，Object的prototype属性是Object.prototype,而由于Object本身是一个函数，由function所创建。</p>\n<p>  所有Object.<em>proto</em>的值是Function.prototype,而Function.prototype的<em>proto</em>属性是Object.prorotype，</p>\n<p>  所有可能判断出 object instanceof object 的结果是true.</p>\n<pre><code>leftValue = Object._proto_ = Function.prototype;\n\nrightValue = Object.prototype\n\n//第一次判断\n\nleftValue != rightValue\n\nleftValue = Function.prototype._proto_ = Object._prototype\n\n//第二次判断\n\nleftValue = rightValue\n</code></pre></li>\n</ol>\n<p>Function instanceof Function和 Function instanceof Object的运行过程与Object instanceof Object类似。故不再详说</p>\n<ol start=\"2\">\n<li><p>Foo instanceof Foo</p>\n<p> Foo函数的prototype 属性是Foo.prototype, 而foo的<em>proto</em>属性是Function.prototype,</p>\n<p> 由图可知，Foo的原型链上并没有Foo.prototype,因此Foo instanceof Foo也就返回false;</p>\n<p> 我们用代码简单的表示一下：</p>\n<pre><code>leftValue = Foo, rightValue = Foo;\nleftValue = Foo._proto = function.prototype;\nrightValue = Foo.prototype;\n//第一次判断\nleftValue != rightValue;\nleftValue = Function.prototype._proto_ = Object.prototype\n//第二次判断\nleftValue != rightValue;\nleftValue = Object.prototype　＝null\n//第三次判断\nleftValue = null;\n</code></pre></li>\n<li><p>Foo instanceof Object</p>\n<pre><code>leftValue = Foo, rightValue = Object\n\nleftValue = Foo.__proto__ = Function.prototype\nrightValue = Object.prototype\n// 第一次判断\nleftValue != rightValue\nleftValue = Function.prototype.__proto__ = Object.prototype\n// 第二次判断\nleftValue === rightValue\n// 返回 true\n</code></pre></li>\n<li><p>Foo instanceof Function</p>\n<pre><code>leftValue = Foo, rightValue = Function\nleftValue = Foo.__proto__ = Function.prototype\nrightValue = Function.prototype\n// 第一次判断\nleftValue === rightValue\n// 返回 true\n</code></pre></li>\n</ol>\n<p>总结来说：</p>\n<p>我们使用typeof　来判断基本类型是OK的。不过需要注意当用typeof 来判断null类型的问题。如果想要判断一个对象的具体类型可以用instanceof 。但是instanceof　可能也判断不准确，例如一个数组，可以被instanceof　判断为Object。</p>\n<p>所以我们想要比较准确的判断一个数的类型时，可以用Object.prototype.toString.tocall 方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"先介绍下js的基本类型和引用类型\"><a href=\"#先介绍下js的基本类型和引用类型\" class=\"headerlink\" title=\"先介绍下js的基本类型和引用类型\"></a>先介绍下js的基本类型和引用类型</h4><p>基本类型： Null,Undefined,Boolean ,Number和String</p>\n<p>引用类型：  Object、Array、RegExp、Date、Function</p>\n<h4 id=\"typeof和instanceof\"><a href=\"#typeof和instanceof\" class=\"headerlink\" title=\"typeof和instanceof\"></a>typeof和instanceof</h4><p>相同点： 都是用来判断一个变量是什么类型的。</p>\n<p>区别：<br>typeof是一元运算放在一个运算数之前可以是任意类型。</p>\n<p>typeof 一般只能返回以下几种类型：Number,String,Boolean,Function, Object,Null,Undefined. Symbol </p>\n<pre><code>我们可以使用typeof 来判断一个变量是否存在，如if(typeof a !== &apos;undefined&apos;){alert(&quot;a&quot;)}; \n最好不要使用if(a) 如果a不存在会报错。\n对于array和null等特殊对象使用typeof 都会返回object。\n</code></pre><p>判断一个变量的类型常常会用typeof，在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象它都会返回object。</p>\n<pre><code>let s = new String(&apos;abc&apos;);\ntypeof s === &apos;object&apos;// true\ns instanceof String // true\n</code></pre><p>此时就需要用到instanceof 来判断。</p>\n<h4 id=\"typeof的原理：\"><a href=\"#typeof的原理：\" class=\"headerlink\" title=\"typeof的原理：\"></a>typeof的原理：</h4><p>我们可以想想js在底层是怎么存储数据的类型信息呢。js的变量的底层实现。</p>\n<p>其实：js在底层存储变量的时候。会在变量的机器码的低位1-3位存储其类型信息。</p>\n<pre><code>000 对象\n010 浮点数\n100 字符串\n110 布尔\n1 整数\n</code></pre><p>但是对与null和undefined来说，这两个值的存储信息是有点特殊的。</p>\n<pre><code>null 所有机器码均为0\nundefined: 用-2^30 整数来表示。\n</code></pre><p>所以判断 typeof null的时候就出现问题了。因为null的机器码，因此就被当作了对象来对待。</p>\n<p>如果用instanceof 来判断的话。</p>\n<pre><code>null instanceof null   //TypeError: Right-hand side of &apos;instanceof&apos; is not an object\n</code></pre><p>还有一个判断类型的方法</p>\n<pre><code>Object.prototype.toString.call(1) //&quot;[object, Number]&quot;\n其他类型以此类推\n</code></pre><h4 id=\"instanceof的原理\"><a href=\"#instanceof的原理\" class=\"headerlink\" title=\"instanceof的原理\"></a>instanceof的原理</h4><p>下面介绍 instanceof<br>instanceof 主要是判断一个实例是否属于某种类型。</p>\n<p>1.</p>\n<pre><code>let person  = function(){}\nlet nichol = new person();\nnichol instanceof person  //true\n</code></pre><p>2.</p>\n<pre><code>let person = function(){}\nlet person_per = function(){}\nperson_per.prototype = new peroson()\n\nlet nichol = new  person_per();\nnichol instanceof person; //true\nnichol instanceof person_per ;  //true \n</code></pre><p>这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p>\n<pre><code>function new_instance_of(leftVaule, rightVaule) {\n    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值\n    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值\n    while (true) {\n        if (leftVaule === null) {\n            return false;\n        }\n        if (leftVaule === rightProto) {\n            return true;\n        }\n        leftVaule = leftVaule.__proto__\n    }\n}\n</code></pre><p>instanceof的实现原理大致就是只要右侧变量的prototype在左侧变量的原型链上即可。</p>\n<p>因此 instanceof在查找的过程中会遍历左侧的原型链，直到找到右侧变量的prototype,如果查找失败就会返回false,告诉我们左侧变量并非是右侧变量的实例、</p>\n<p>举个栗子：</p>\n<pre><code>function foo(){\n\n}\nfunction instanceof Object //true\nfunction instanceof function //true\nObject instanceof Object //true\nfoo instanceof Object //true\nfoo instanceof foo //false\nfoo instanceof function //true\n</code></pre><p>下面我们来一一解释其结果为什么这样：<br>这就涉及到javascript的继承原理<br>关于原型继承的原理，我简单用一张图来表示<br><img src=\"https://i.imgur.com/X44Z17j.png\" alt=\"\"></p>\n<p>每个javascript对象都有一个隐式的<em>proto</em> 原型属性。而显示属性是prototype, 只有object.prototype.<em>proto</em>属性在未修改的情况下为null值。</p>\n<p>根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。</p>\n<ol>\n<li><p>object instanceof object</p>\n<p>  由图可知，Object的prototype属性是Object.prototype,而由于Object本身是一个函数，由function所创建。</p>\n<p>  所有Object.<em>proto</em>的值是Function.prototype,而Function.prototype的<em>proto</em>属性是Object.prorotype，</p>\n<p>  所有可能判断出 object instanceof object 的结果是true.</p>\n<pre><code>leftValue = Object._proto_ = Function.prototype;\n\nrightValue = Object.prototype\n\n//第一次判断\n\nleftValue != rightValue\n\nleftValue = Function.prototype._proto_ = Object._prototype\n\n//第二次判断\n\nleftValue = rightValue\n</code></pre></li>\n</ol>\n<p>Function instanceof Function和 Function instanceof Object的运行过程与Object instanceof Object类似。故不再详说</p>\n<ol start=\"2\">\n<li><p>Foo instanceof Foo</p>\n<p> Foo函数的prototype 属性是Foo.prototype, 而foo的<em>proto</em>属性是Function.prototype,</p>\n<p> 由图可知，Foo的原型链上并没有Foo.prototype,因此Foo instanceof Foo也就返回false;</p>\n<p> 我们用代码简单的表示一下：</p>\n<pre><code>leftValue = Foo, rightValue = Foo;\nleftValue = Foo._proto = function.prototype;\nrightValue = Foo.prototype;\n//第一次判断\nleftValue != rightValue;\nleftValue = Function.prototype._proto_ = Object.prototype\n//第二次判断\nleftValue != rightValue;\nleftValue = Object.prototype　＝null\n//第三次判断\nleftValue = null;\n</code></pre></li>\n<li><p>Foo instanceof Object</p>\n<pre><code>leftValue = Foo, rightValue = Object\n\nleftValue = Foo.__proto__ = Function.prototype\nrightValue = Object.prototype\n// 第一次判断\nleftValue != rightValue\nleftValue = Function.prototype.__proto__ = Object.prototype\n// 第二次判断\nleftValue === rightValue\n// 返回 true\n</code></pre></li>\n<li><p>Foo instanceof Function</p>\n<pre><code>leftValue = Foo, rightValue = Function\nleftValue = Foo.__proto__ = Function.prototype\nrightValue = Function.prototype\n// 第一次判断\nleftValue === rightValue\n// 返回 true\n</code></pre></li>\n</ol>\n<p>总结来说：</p>\n<p>我们使用typeof　来判断基本类型是OK的。不过需要注意当用typeof 来判断null类型的问题。如果想要判断一个对象的具体类型可以用instanceof 。但是instanceof　可能也判断不准确，例如一个数组，可以被instanceof　判断为Object。</p>\n<p>所以我们想要比较准确的判断一个数的类型时，可以用Object.prototype.toString.tocall 方法。</p>\n"},{"title":"Javascript 面向对象","_content":"\n####  封装  \n\n\thttp://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\n\n\n\n\n","source":"_posts/继承.md","raw":"---\ntitle: Javascript 面向对象\n---\n\n####  封装  \n\n\thttp://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\n\n\n\n\n","slug":"继承","published":1,"date":"2018-04-16T11:31:44.000Z","updated":"2018-04-16T11:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposi000gg4s6guorelye","content":"<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><pre><code>http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><pre><code>http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\n</code></pre>"},{"title":"js常用跨域方法","_content":"\n---\n","source":"_posts/跨域.md","raw":"---\ntitle: js常用跨域方法\n---\n\n---\n","slug":"跨域","published":1,"date":"2018-09-21T05:58:50.000Z","updated":"2018-09-21T05:58:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposj000hg4s6lc2wptph","content":"<hr>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n"},{"title":"页面的重绘和重排","_content":"\n### 1. 重绘 （Repaint）\n重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，\n使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。\n\n### 2.重排 (Reflow)\n\t渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局和重排。","source":"_posts/页面的重绘和重排.md","raw":"---\ntitle: 页面的重绘和重排\n---\n\n### 1. 重绘 （Repaint）\n重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，\n使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。\n\n### 2.重排 (Reflow)\n\t渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局和重排。","slug":"页面的重绘和重排","published":1,"date":"2018-04-16T11:31:44.000Z","updated":"2018-04-16T11:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposk000ig4s66x2airxs","content":"<h3 id=\"1-重绘-（Repaint）\"><a href=\"#1-重绘-（Repaint）\" class=\"headerlink\" title=\"1. 重绘 （Repaint）\"></a>1. 重绘 （Repaint）</h3><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，<br>使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</p>\n<h3 id=\"2-重排-Reflow\"><a href=\"#2-重排-Reflow\" class=\"headerlink\" title=\"2.重排 (Reflow)\"></a>2.重排 (Reflow)</h3><pre><code>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局和重排。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-重绘-（Repaint）\"><a href=\"#1-重绘-（Repaint）\" class=\"headerlink\" title=\"1. 重绘 （Repaint）\"></a>1. 重绘 （Repaint）</h3><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，<br>使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</p>\n<h3 id=\"2-重排-Reflow\"><a href=\"#2-重排-Reflow\" class=\"headerlink\" title=\"2.重排 (Reflow)\"></a>2.重排 (Reflow)</h3><pre><code>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局和重排。\n</code></pre>"},{"title":"过去的贰零壹柒年（魚丁系）","_content":"\n首先为什么叫魚丁系呢。\n\n分别取蘇打綠的一个偏旁。\n\n2017年过的好快。过的像天气时好时坏。","source":"_posts/鱼丁系.md","raw":"---\ntitle: 过去的贰零壹柒年（魚丁系）\n---\n\n首先为什么叫魚丁系呢。\n\n分别取蘇打綠的一个偏旁。\n\n2017年过的好快。过的像天气时好时坏。","slug":"鱼丁系","published":1,"date":"2018-01-28T08:44:08.000Z","updated":"2018-01-28T08:44:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbmposl000jg4s6tqiz48ib","content":"<p>首先为什么叫魚丁系呢。</p>\n<p>分别取蘇打綠的一个偏旁。</p>\n<p>2017年过的好快。过的像天气时好时坏。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先为什么叫魚丁系呢。</p>\n<p>分别取蘇打綠的一个偏旁。</p>\n<p>2017年过的好快。过的像天气时好时坏。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}