<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangqun</title>
  
  <subtitle>平凡的人生，不平凡的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qunqunyang.me/"/>
  <updated>2018-12-24T05:45:28.263Z</updated>
  <id>http://qunqunyang.me/</id>
  
  <author>
    <name>qunqunyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>promise</title>
    <link href="http://qunqunyang.me/2018/12/24/promise%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://qunqunyang.me/2018/12/24/promise的前世今生/</id>
    <published>2018-12-24T04:56:14.383Z</published>
    <updated>2018-12-24T05:45:28.263Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js常用跨域方法</title>
    <link href="http://qunqunyang.me/2018/09/21/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://qunqunyang.me/2018/09/21/跨域/</id>
    <published>2018-09-21T05:58:51.299Z</published>
    <updated>2018-09-21T05:58:51.300Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js数组方法大全</title>
    <link href="http://qunqunyang.me/2018/07/16/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
    <id>http://qunqunyang.me/2018/07/16/js数组方法大全/</id>
    <published>2018-07-16T02:33:50.285Z</published>
    <updated>2018-09-21T05:56:26.667Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><pre><code>js数组也是我们平常操作最多的，本篇整理了js数组的所能想到的方法，作为参考用。 其实也是面试时经常会问道的一部分。</code></pre><h3 id="1、数组创建"><a href="#1、数组创建" class="headerlink" title="1、数组创建"></a>1、数组创建</h3><p>JavaScript 数组创建有两种方法：<br>第一种是使用Array构造函数</p><pre><code>var array = new Array();</code></pre><p>第二种方法是使用数组字面量创建数组</p><pre><code>var array = [];var array = [10];</code></pre><p>如何确定是不是数组呢！ Array.isArray()</p><h3 id="2、数组的方法"><a href="#2、数组的方法" class="headerlink" title="2、数组的方法"></a>2、数组的方法</h3><blockquote><p>join()<br>push() 和 pop()<br>shift()和unshift()<br>sort() 和 reverse()<br>concat()<br>splice()和slice()<br>indexOf 和 lastIndexOf<br>foreach, map, filter, every ,some,reduce, reduceRight</p></blockquote><p>下面详细讲下每一个的作用：</p><h4 id="1）-join"><a href="#1）-join" class="headerlink" title="1）  join()"></a>1）  join()</h4><blockquote><p>将数组的元素转变成一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符</p></blockquote><pre><code>var arr = [1,2,3];arr.join(,); //1，2，3</code></pre><p>通过join()可以实现重复字符串。</p><pre><code>function repeatString(str,n){    return new Array(n+1).joint(str)}console.log(repeatString(&quot;abc&quot;, 3)); // abcabcabc</code></pre><h4 id="2-push-和pop"><a href="#2-push-和pop" class="headerlink" title="2) push()和pop():"></a>2) push()和pop():</h4><blockquote><p>push可以添加想要数量的参数，把他放到数组的末尾，返回数组的长度。<br>pop数组末尾减少最后一项，返回数组的长度<br>  push和pop正好对应，一个操作数组开始，一个操作末尾。</p></blockquote><h4 id="3）shift-和unshift"><a href="#3）shift-和unshift" class="headerlink" title="3）shift() 和unshift()"></a>3）shift() 和unshift()</h4><blockquote><p>shift():删除原数组的第一项并返回该项的值。<br>unshift()：将参数添加到原数组的第一项并返回数组的长度。</p></blockquote><p>这组方法跟push和pop方法类似，都是操作数组的开始和末尾。</p><h4 id="4）sort"><a href="#4）sort" class="headerlink" title="4）sort()"></a>4）sort()</h4><blockquote><p>按升序排列数组项，即最小的值位于最前面，最大的值排在最后面。<br>在排序时，sort方法会调用数组方法的tostring方法，然后比较得到的字符串确定如何排序，即使数组中的每一项都是数值，sort方法比较的也是字符串。</p></blockquote><pre><code>var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];console.log(arr1.sort()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]arr2 = [13, 24, 51, 3];console.log(arr2.sort()); // [13, 24, 3, 51]console.log(arr2); // [13, 24, 3, 51](元数组被改变)</code></pre><p> 解决上述问题:<br> sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值  的前面。<br> 比较函数接收两个参数，<br> 如果第一个参数应该位于第二个之前则返回一个负数，<br> 如果两个参数相等则返回0，<br> 如果第一个参数应该位于第二个之后则返回一个正数。<br> 以下就是一个简单的比较函数：</p><pre><code>function compare(v1,v2){    if(v1&lt;v2){        return -1;    } else if(v1&gt; v2){        return 1;    } else {        return 0;    }}var arr1 = [13, 24, 3, 51];console.log(arr1.sort(compare));</code></pre><p>如果想要降序的排序结果，只需要在函数内交换一下判断条件。<br>reverse(): </p><blockquote><p>反转数组项的顺序。</p></blockquote><pre><code>var arr = [13, 24, 51, 3];console.log(arr.reverse()); //[3, 51, 24, 13]console.log(arr); //[3, 51, 24, 13](原数组改变)</code></pre><h4 id="5-concat"><a href="#5-concat" class="headerlink" title="5)concat()"></a>5)concat()</h4><blockquote><p>将参数添加到原数组中，这个方法会先创建当前数组一个副本，然后接收到的数组添加到这个数组的末尾，最后返回新创建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p></blockquote><pre><code>var arr = [1,3,5,7];var arrCopy = arr.concat(9,[11,13]);console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7](原数组未被修改)如果传入的是二维数组var arrCopy2 = arr.concat([9,[11,13]]);console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]console.log(arrCopy2[5]); //[11, 13]</code></pre><p>上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。</p><h4 id="6-slice-："><a href="#6-slice-：" class="headerlink" title="6) slice()："></a>6) slice()：</h4><blockquote><p>返回从原数组中指定开始下标到结束下标之间的项组成的新数组。</p></blockquote><p>slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。<br>在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p><pre><code>var arr = [1,3,5,7,9,11];var arrCopy = arr.slice(1);var arrCopy2 = arr.slice(1,4);var arrCopy3 = arr.slice(1,-2);var arrCopy4 = arr.slice(-4,-1);console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); //[3, 5, 7, 9, 11]console.log(arrCopy2); //[3, 5, 7]console.log(arrCopy3); //[3, 5, 7]console.log(arrCopy4); //[5, 7, 9]</code></pre><p>splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换<br>删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。<br>例如， splice(0,2)会删除数组中的前两项。<br>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。<br>例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。<br>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6<br>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组</p><pre><code>var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7]</code></pre><h4 id="7-indexOf-和lastIndexOf"><a href="#7-indexOf-和lastIndexOf" class="headerlink" title="7) indexOf()和lastIndexOf()"></a>7) indexOf()和lastIndexOf()</h4><blockquote><p>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。<br>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p></blockquote><p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</p><pre><code>var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf(&quot;5&quot;)); //-1</code></pre><h4 id="8-foreach"><a href="#8-foreach" class="headerlink" title="8) foreach()"></a>8) foreach()</h4><blockquote><p>对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型。</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a){console.log(x + &apos;|&apos; + index + &apos;|&apos; + (a === arr));});// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true</code></pre><h4 id="9-map"><a href="#9-map" class="headerlink" title="9) map()"></a>9) map()</h4><blockquote><p>指映射,对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item){return item*item;});console.log(arr2); //[1, 4, 9, 16, 25]</code></pre><h4 id="10-filter"><a href="#10-filter" class="headerlink" title="10) filter()"></a>10) filter()</h4><blockquote><p>过滤功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) {return index % 3 === 0 || x &gt;= 8;}); console.log(arr2); //[1, 4, 7, 8, 9, 10]</code></pre><h4 id="11-every"><a href="#11-every" class="headerlink" title="11) every()"></a>11) every()</h4><blockquote><p>判断数组中每一项是否满足条件，只有所有项都满足条件才会返回true。</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) {return x &lt; 10;}); console.log(arr2); //truevar arr3 = arr.every(function(x) {return x &lt; 3;}); console.log(arr3); // false</code></pre><h4 id="12-some"><a href="#12-some" class="headerlink" title="12) some()"></a>12) some()</h4><blockquote><p>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) {return x &lt; 3;}); console.log(arr2); //truevar arr3 = arr.some(function(x) {return x &lt; 1;}); console.log(arr3); // false</code></pre><h4 id="13-reduce-和-reduceRight"><a href="#13-reduce-和-reduceRight" class="headerlink" title="13) reduce()和 reduceRight()"></a>13) reduce()和 reduceRight()</h4><blockquote><p>两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。<br>reduce()方法从数组的第一项开始，逐个遍历到最后。 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p></blockquote><p>这两个方法都接收两个参数：<br>一个在每一项上调用的函数和（可选的）作为归并基础的初始值。<br>传给 reduce()和 reduceRight()的函数<br>接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p><p>下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。</p><pre><code>var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array){    return prev + cur;},10);console.log(sum); //25</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;js数组也是我们平常操作最多的，本篇整理了js数组的所能想到的方法，作为参考用。 其实也是面试时经常会问道的一部分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Object类的常用方法 （二）</title>
    <link href="http://qunqunyang.me/2018/06/20/Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://qunqunyang.me/2018/06/20/Object类的常用方法（二）/</id>
    <published>2018-06-20T01:57:50.458Z</published>
    <updated>2018-06-20T12:30:14.674Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>续上文Object类的常用方法（一）</p><p>上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()<br>本篇文章会有点枯燥捏！</p></blockquote><p>下面就按顺序排了</p><h5 id="5、-Object-entries"><a href="#5、-Object-entries" class="headerlink" title="5、 Object.entries:"></a>5、 Object.entries:</h5><blockquote><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p></blockquote><pre><code>Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。参数： Object.entries(obj), 其中 obj 可以返回其可枚举属性的键值对的对象。返回值： 给定对象自身可枚举属性的键值对数组。</code></pre><p>举个栗子：</p><pre><code>const obj = { foo: &apos;bar&apos;, baz: 42 };console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]// array like objectconst obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };console.log(Object.entries(obj)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]// array like object with random key orderingconst anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };console.log(Object.entries(anObj)); // [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]// getFoo is property which isn&apos;t enumerableconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });myObj.foo = &apos;bar&apos;;console.log(Object.entries(myObj)); // [ [&apos;foo&apos;, &apos;bar&apos;] ]// non-object argument will be coerced to an objectconsole.log(Object.entries(&apos;foo&apos;)); // [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]// iterate through key-value gracefullyconst obj = { a: 5, b: 7, c: 9 };for (const [key, value] of Object.entries(obj)) {  console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;}// Or, using array extrasObject.entries(obj).forEach(([key, value]) =&gt; {console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;});</code></pre><h5 id="6、-Object-create"><a href="#6、-Object-create" class="headerlink" title="6、 Object.create:"></a>6、 Object.create:</h5><blockquote><p><code>Object.create()</code> 方法会使用指定的原型对象及其属性去创建一个新的对象</p><p>Object.create(proto[, propertiesObject])</p><p>其中参数proto为一个对象，作为新创建对象的原型</p><p>propertiesObject: 对象，可选参数，为新创建的对象指定属性对象。</p></blockquote><p><strong> 注意，使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。</strong></p><p>来看一个简单的例子：</p><pre><code>// 基类function Site() {  this.name = &apos;Site&apos;;  this.domain = &apos;domain&apos;;}Site.prototype.create = function(name, domain) {  this.name = name;  this.domain = domain;};// 子类function Itbilu() {  Site.call(this); //调用基类的构造函数}// 继承父类Itbilu.prototype = Object.create(Site.prototype);// 创建类实例var itbilu = new Itbilu();itbilu instanceof Site;  // truetbilu instanceof Itbilu;  // trueitbilu.create(&apos;IT笔录&apos;, &apos;itbilu.com&apos;);itbilu.name;    // &apos;IT笔录&apos;itbilu.domain;  // &apos;itbilu.com&apos;</code></pre><p>使用 <code>Object.create()</code> 的 propertyObject参数</p><pre><code>var o;// 创建一个原型为null的空对象o = Object.create(null);o = {};// 以字面量方式创建的空对象就相当于:o = Object.create(Object.prototype);o = Object.create(Object.prototype, {  // foo会成为所创建对象的数据属性  foo: {     writable:true,    configurable:true,    value: &quot;hello&quot;   },  // bar会成为所创建对象的访问器属性  bar: {    configurable: false,    get: function() { return 10 },    set: function(value) {      console.log(&quot;Setting `o.bar` to&quot;, value);    }  }});</code></pre><h5 id="7、Object-defineProperty"><a href="#7、Object-defineProperty" class="headerlink" title="7、Object.defineProperty"></a>7、Object.defineProperty</h5><pre><code>语法： Object.defineProperty(obj, prop, descriptor)参数：     obj：必需。目标对象     prop：必需。需定义或修改的属性的名字    descriptor：必需。目标属性所拥有的特性返回值： 传入函数的对象。即第一个参数obj</code></pre><p>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历</p><p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p><p>数据描述：<br>当修改或者定义对象的某个属性的时候，给这个属性添加一些特性：</p><pre><code>var obj = {    test:&quot;hello&quot;}//对象已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});//对象新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});</code></pre><p>数据描述中的属性都是可选的。看一下每个设置的作用。</p><p>1) value： 属性对应的值,可以使任意类型的值，默认为undefined</p><pre><code>var obj = {};//第一种情况，不设置value属性。Object.defineProperty(obj,&quot;newKey&quot;,{})console.log(obj.newKey);   //undefined    //第二种 设置value属性Object.defineProperty(obj,&quot;newKey&quot;,{    value： &apos;hello&apos;})console.log(obj.newKey);   //hello    </code></pre><p>2) writable<br>    属性的值是否可以被重写。设置为true可以被重写，设置为false,不可被重写。 默认为false</p><pre><code>var obj = {}//第一种情况：writable设置为false，不能重写。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //hello//第二种情况：writable设置为true，可以重写Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //change value</code></pre><p>3)  enumerable<br>此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p><pre><code>var obj = {}//第一种情况：enumerable设置为false，不能被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false});//枚举对象的属性for( var attr in obj ){    console.log( attr );  }//第二种情况：enumerable设置为true，可以被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:true});//枚举对象的属性for( var attr in obj ){    console.log( attr );  //newKey}</code></pre><p>4)  configurable</p><pre><code>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。这个属性起到两个作用：1. 目标属性是否可以使用delete删除2. 目标属性是否可以再次设置特性    //-----------------测试目标属性是否能被删除------------------------    var obj = {}    //第一种情况：configurable设置为false，不能被删除。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:false    });    //删除属性    delete obj.newKey;    console.log( obj.newKey ); //hello    //第二种情况：configurable设置为true，可以被删除。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:true    });    //删除属性    delete obj.newKey;    console.log( obj.newKey ); //undefined    //-----------------测试是否可以再次修改特性------------------------    var obj = {}    //第一种情况：configurable设置为false，不能再次修改特性。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:false    });    //重新修改特性    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:true,        enumerable:true,        configurable:true    });    console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey    //第二种情况：configurable设置为true，可以再次修改特性。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:true    });    //重新修改特性    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:true,        enumerable:true,        configurable:true    });    console.log( obj.newKey ); //hello</code></pre><p>除了给新特性的属性设置特性，也可以给已有的属性设置特性。</p><pre><code>//定义对象的时候添加的属性，是可删除、可重写、可枚举的。var obj = {    test:&quot;hello&quot;}//改写值obj.test = &apos;change value&apos;;console.log( obj.test ); //&apos;change value&apos;Object.defineProperty(obj,&quot;test&quot;,{    writable:false})//再次改写值obj.test = &apos;change value again&apos;;console.log( obj.test ); //依然是：&apos;change value&apos;</code></pre><p><strong> 提示： 一旦使用<code>Object.defineProperty()</code>给对象添加属性，那么如果不设置属性的特性，那么configrable,enumerable,writable这些值都是默认的false。</strong></p><pre><code>var obj = {};定义新属性后，这个属性的特性中，都是默认为false。这就导致了newKey这个是不能重写，不能枚举，不能再次设置特性。//Object.defineProperty(obj,&apos;newKey&apos;,{});//设置值obj.newKey = &apos;hello&apos;;console.log(obj.newKey);  //undefined//枚举for( var attr in obj ){    console.log(attr);}</code></pre><p>特性总结：</p><blockquote><p>value: 设置属性的值<br>writable: 值是否可以重写。true | false<br>enumerable: 目标属性是否可以被枚举。true | false<br>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false</p><h5 id="8、Object-hasOwnProperty（）"><a href="#8、Object-hasOwnProperty（）" class="headerlink" title="8、Object.hasOwnProperty（）"></a>8、Object.hasOwnProperty（）</h5><p>用于知识一个对象自身是否具有指定名称的属性，如果有返回true， 如果没有返回false。</p></blockquote><pre><code>语法 ：object.hasOwnProperty(propertyName)propertyName：指定的属性名称返回值： hasOwnProperty（）返回的值是Boolean类型。如果对象Object具有名称为propertyName的属性，则返回true    ,否则返回false。</code></pre><p>此方法不会检查对象的原型链中是否存在此属性，该属性只有是对象本身的一个成员才会返回true。</p><p>举个例子：</p><pre><code>function isHas(){    this.name = &apos;today&apos;,    this.week = &apos;wendsday&apos;,    this.sayHi = function(){        document.writeln(&apos;今天是&apos;+this.name);    }}var obj = {    mood = &apos;happy&apos;,    sayHello = function(){        document.writeln(&apos;今天的心情是&apos;+this.mood);    }}</code></pre><p>//使用对象obj覆盖Site本身的prototype属性</p><pre><code>isHas.prototype = obj;var h = new isHas();document.writeln(s.hasOwnProperty(&apos;name&apos;)); //truedocument.writeln(s.hasOwnProperty(&apos;sayHi&apos;)); //true//以下属性继承自原型链，所以为falsedocument.writeln(s.hasOwnProperty(&apos;mood&apos;)); //falsedocument.writeln(s.hasOwnProperty(&apos;sayHello&apos;)); //false// 想要查看对象(包括原型链)是否具备指定的属性，可以使用in操作符document.writeln(&apos;mood&apos; in s); //truedocument.writeln(&apos;sayHello&apos; in s); //true</code></pre><p> 完结！ 后续有更新再添加！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;续上文Object类的常用方法（一）&lt;/p&gt;
&lt;p&gt;上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()&lt;br&gt;本篇文章会有点枯燥捏！&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Object类的常用方法 （一）</title>
    <link href="http://qunqunyang.me/2018/06/15/Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://qunqunyang.me/2018/06/15/Object类的常用方法/</id>
    <published>2018-06-15T10:17:28.785Z</published>
    <updated>2018-06-15T10:17:28.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote><p>js中对Object的一些操作</p><p>对象是值： 成对的名称（字符串）和值（任何值），其中名称通过冒号与值分隔；    </p></blockquote><h4 id="一-、创建对象的方法："><a href="#一-、创建对象的方法：" class="headerlink" title="一 、创建对象的方法："></a>一 、创建对象的方法：</h4><ol><li><p>字面量形式：</p><p> var obj = {</p><pre><code>a:1，b:2</code></pre><p> }; </p></li><li><p>对象实例</p><p> var obj = new Object();</p></li><li><p>构造函数形式</p><pre><code>function employee(name,job,born) {    this.name=name;    this.job=job;    this.born=born;}var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);// employee {name: &quot;Bill Gates&quot;, job: &quot;Engineer&quot;, born: 1985} </code></pre></li></ol><ol><li><p>es6 class模式</p><p> //定义类</p><pre><code>class point = {    constructor(x,y){        this.x = x;        this.y = y;        };    //定义方法    tostring(){        return &apos;(&apos;+this.x+&apos;,&apos;+this.y+&apos;)&apos;;    }    multiplication(){        return this.x*this.y    }    test(){        return &apos;1234567890&apos;    }}console.log(point.name)//Point （name属性总是返回紧跟在class关键字后面的类名。）// 实例化并调用（实例化和调用方法同es5相同）var x = new Point(5, 6)console.log(x.toString(), &apos;相乘结果：&apos; + x.multiplication(), x.test())// (5, 6) 相乘结果：30 1231354654// 快速添加方法到原型上 （如下图，直接可添加到原型）Object.assign(Point.prototype, {    dosomething() { },    toValue() { }});console.log(Point.prototype)</code></pre></li></ol><h4 id="二、Object的常用方法"><a href="#二、Object的常用方法" class="headerlink" title="二、Object的常用方法"></a>二、Object的常用方法</h4><h5 id="1、-Object-assign：-浅拷贝复制"><a href="#1、-Object-assign：-浅拷贝复制" class="headerlink" title="1、 Object.assign：  浅拷贝复制"></a>1、 Object.assign：  浅拷贝复制</h5><blockquote><p>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 Object.assign(target, …sources)</p></blockquote><p>参数:</p><p>target:目标对象;sources:源对象;返回值:目标对象</p><ol><li><p>复制一个对象，并不会影响原对象</p><pre><code>var obj = {a:1};var copy = Object.assign({},obj);console.log(copy) // {a:1}</code></pre></li><li><p>合并对象</p><pre><code>//object.assign(obj, obj2)  obj2是源对象，obj 是目标对象，返回目标对象var obj = { a: 1 };var obj2={b:2};console.log(Object.assign(obj,obj2)===obj);  //true，返回目标对象console.log(obj);       //{a:1,b:2} obj的值已被更改</code></pre></li><li><p>如果目标对象和源对象有相同的属性，则会被覆盖，后面的对象会覆盖掉前面的属性</p></li></ol><pre><code>var obj = { a: 1 };var obj1 = {a:2,b:5};var obj2={b:2};Object.assign(obj,obj1,obj2);  //{a:2,b:2}</code></pre><ol><li><p>当assign只有一个对象时，则直接返回这个对象，不做任何操作</p></li><li><p>Object.assign是浅拷贝，copy的是一个对象的引用</p><pre><code>var obj1 = { a: 0 , b: { c: 0}};var obj2 = Object.assign({}, obj1);obj1.b.c=5;console.log(obj2)       //{a:0,b:{c:5}};</code></pre><p> 当我们在改变obj1的值时，并没有想改变obj2，但obj2的值也发生了改变，这违背了我们的想法</p></li><li><p>深拷贝</p><pre><code>var obj = { a: 0 , b: { c: 0}};var obj2 = JSON.parse(JSON.stringify(obj));obj.a = 4;obj.b.c = 4;console.log(obj2)   //{ a: 0 , b: { c: 0}}</code></pre></li></ol><h5 id="2、-Object-is"><a href="#2、-Object-is" class="headerlink" title="2、 Object.is()"></a>2、 Object.is()</h5><p>判断两个值是否是同一个值 </p><p>参数:  Object.is(value1,value2)</p><p>value1:需要比较的第一个值。 value2:需要比较的第二个值。 返回值:表示两个参数是否相同的Boolean</p><pre><code>Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;);     // trueObject.is(window, window);   // trueObject.is(&apos;foo&apos;, &apos;bar&apos;);     // falseObject.is([], []);           // falsevar test = { a: 1 };Object.is(test, test);       // trueObject.is(null, null);       // true// 特例Object.is(0, -0);            // falseObject.is(-0, -0);           // trueObject.is(NaN, 0/0);         // true    </code></pre><h5 id="3、-Object-keys"><a href="#3、-Object-keys" class="headerlink" title="3、 Object.keys()"></a>3、 Object.keys()</h5><blockquote><p>这个方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p></blockquote><pre><code>1）数组对象    var arr=[1,2,3];                Object.keys(arr)         //  [&quot;0&quot;, &quot;1&quot;, &quot;2”]2） object对象    var obj = { foo: &quot;bar&quot;, baz: 42 };    Object.keys(obj)        //  [&quot;foo&quot;, &quot;baz”](3)类数组，对象    var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c”};    Object.keys(obj)       // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] </code></pre><h5 id="4、-Object-values"><a href="#4、-Object-values" class="headerlink" title="4、 Object.values()"></a>4、 Object.values()</h5><blockquote><p>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for..in循环相同，返回的对象的value值，与Object.key()相反</p></blockquote><pre><code>var obj = {a:1,b:2,c:3};console.log(Object.values(obj))   //  [1, 2, 3]var obj ={0:&apos;a&apos;,1:&apos;b&apos;,2:&apos;c&apos;};console.log(Object.values(obj)).       //  a,b,cvar obj={100:&apos;a&apos;,10:&apos;b&apos;,1:&apos;1&apos;};console.log(Object.values(obj)).   // [&quot;1&quot;, &quot;b&quot;, &quot;a&quot;]</code></pre><h5 id="待更新："><a href="#待更新：" class="headerlink" title="待更新："></a>待更新：</h5><h5 id="5、-Object-entries"><a href="#5、-Object-entries" class="headerlink" title="5、 Object.entries:"></a>5、 Object.entries:</h5><h5 id="6、-Object-create"><a href="#6、-Object-create" class="headerlink" title="6、 Object.create:"></a>6、 Object.create:</h5><h5 id="7、-Object-defineProperties"><a href="#7、-Object-defineProperties" class="headerlink" title="7、 Object.defineProperties"></a>7、 Object.defineProperties</h5><h5 id="8、Object-defineProperty"><a href="#8、Object-defineProperty" class="headerlink" title="8、Object.defineProperty"></a>8、Object.defineProperty</h5><h5 id="9、Object-hasOwnProperty"><a href="#9、Object-hasOwnProperty" class="headerlink" title="9、Object.hasOwnProperty"></a>9、Object.hasOwnProperty</h5><p>其他不常用方法：</p><pre><code>1、Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。2、Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。3、Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。4、Object.isSealed() 方法判断一个对象是否是密封的（sealed）。5、Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;js中对Object的一些操作&lt;/p&gt;
&lt;p&gt;对象是值： 成对的名称（字符串）和值（任何值），其中名称通过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js的基本类型和引用类型</title>
    <link href="http://qunqunyang.me/2018/06/11/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://qunqunyang.me/2018/06/11/js的基本类型和引用类型/</id>
    <published>2018-06-11T02:36:43.928Z</published>
    <updated>2018-07-16T05:40:01.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、基本类型和引用类型的区别："><a href="#1、基本类型和引用类型的区别：" class="headerlink" title="1、基本类型和引用类型的区别："></a>1、基本类型和引用类型的区别：</h3><p>1） 基本类型： </p><p>2）  引用类型</p><p>3） 两者区别</p><p>4） 操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、基本类型和引用类型的区别：&quot;&gt;&lt;a href=&quot;#1、基本类型和引用类型的区别：&quot; class=&quot;headerlink&quot; title=&quot;1、基本类型和引用类型的区别：&quot;&gt;&lt;/a&gt;1、基本类型和引用类型的区别：&lt;/h3&gt;&lt;p&gt;1） 基本类型： &lt;/p&gt;
&lt;p&gt;2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈typeof 和instanceof的区别</title>
    <link href="http://qunqunyang.me/2018/06/11/%E6%B5%85%E8%B0%88%20typeof%20%E5%92%8C%20instanceof%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://qunqunyang.me/2018/06/11/浅谈 typeof 和 instanceof的区别/</id>
    <published>2018-06-11T01:50:10.557Z</published>
    <updated>2018-06-11T10:02:18.325Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先介绍下js的基本类型和引用类型"><a href="#先介绍下js的基本类型和引用类型" class="headerlink" title="先介绍下js的基本类型和引用类型"></a>先介绍下js的基本类型和引用类型</h4><p>基本类型： Null,Undefined,Boolean ,Number和String</p><p>引用类型：  Object、Array、RegExp、Date、Function</p><h4 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h4><p>相同点： 都是用来判断一个变量是什么类型的。</p><p>区别：<br>typeof是一元运算放在一个运算数之前可以是任意类型。</p><p>typeof 一般只能返回以下几种类型：Number,String,Boolean,Function, Object,Null,Undefined. Symbol </p><pre><code>我们可以使用typeof 来判断一个变量是否存在，如if(typeof a !== &apos;undefined&apos;){alert(&quot;a&quot;)}; 最好不要使用if(a) 如果a不存在会报错。对于array和null等特殊对象使用typeof 都会返回object。</code></pre><p>判断一个变量的类型常常会用typeof，在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象它都会返回object。</p><pre><code>let s = new String(&apos;abc&apos;);typeof s === &apos;object&apos;// trues instanceof String // true</code></pre><p>此时就需要用到instanceof 来判断。</p><h4 id="typeof的原理："><a href="#typeof的原理：" class="headerlink" title="typeof的原理："></a>typeof的原理：</h4><p>我们可以想想js在底层是怎么存储数据的类型信息呢。js的变量的底层实现。</p><p>其实：js在底层存储变量的时候。会在变量的机器码的低位1-3位存储其类型信息。</p><pre><code>000 对象010 浮点数100 字符串110 布尔1 整数</code></pre><p>但是对与null和undefined来说，这两个值的存储信息是有点特殊的。</p><pre><code>null 所有机器码均为0undefined: 用-2^30 整数来表示。</code></pre><p>所以判断 typeof null的时候就出现问题了。因为null的机器码，因此就被当作了对象来对待。</p><p>如果用instanceof 来判断的话。</p><pre><code>null instanceof null   //TypeError: Right-hand side of &apos;instanceof&apos; is not an object</code></pre><p>还有一个判断类型的方法</p><pre><code>Object.prototype.toString.call(1) //&quot;[object, Number]&quot;其他类型以此类推</code></pre><h4 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h4><p>下面介绍 instanceof<br>instanceof 主要是判断一个实例是否属于某种类型。</p><p>1.</p><pre><code>let person  = function(){}let nichol = new person();nichol instanceof person  //true</code></pre><p>2.</p><pre><code>let person = function(){}let person_per = function(){}person_per.prototype = new peroson()let nichol = new  person_per();nichol instanceof person; //truenichol instanceof person_per ;  //true </code></pre><p>这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p><pre><code>function new_instance_of(leftVaule, rightVaule) {    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值    while (true) {        if (leftVaule === null) {            return false;        }        if (leftVaule === rightProto) {            return true;        }        leftVaule = leftVaule.__proto__    }}</code></pre><p>instanceof的实现原理大致就是只要右侧变量的prototype在左侧变量的原型链上即可。</p><p>因此 instanceof在查找的过程中会遍历左侧的原型链，直到找到右侧变量的prototype,如果查找失败就会返回false,告诉我们左侧变量并非是右侧变量的实例、</p><p>举个栗子：</p><pre><code>function foo(){}function instanceof Object //truefunction instanceof function //trueObject instanceof Object //truefoo instanceof Object //truefoo instanceof foo //falsefoo instanceof function //true</code></pre><p>下面我们来一一解释其结果为什么这样：<br>这就涉及到javascript的继承原理<br>关于原型继承的原理，我简单用一张图来表示<br><img src="https://i.imgur.com/X44Z17j.png" alt=""></p><p>每个javascript对象都有一个隐式的<em>proto</em> 原型属性。而显示属性是prototype, 只有object.prototype.<em>proto</em>属性在未修改的情况下为null值。</p><p>根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。</p><ol><li><p>object instanceof object</p><p>  由图可知，Object的prototype属性是Object.prototype,而由于Object本身是一个函数，由function所创建。</p><p>  所有Object.<em>proto</em>的值是Function.prototype,而Function.prototype的<em>proto</em>属性是Object.prorotype，</p><p>  所有可能判断出 object instanceof object 的结果是true.</p><pre><code>leftValue = Object._proto_ = Function.prototype;rightValue = Object.prototype//第一次判断leftValue != rightValueleftValue = Function.prototype._proto_ = Object._prototype//第二次判断leftValue = rightValue</code></pre></li></ol><p>Function instanceof Function和 Function instanceof Object的运行过程与Object instanceof Object类似。故不再详说</p><ol><li><p>Foo instanceof Foo</p><p> Foo函数的prototype 属性是Foo.prototype, 而foo的<em>proto</em>属性是Function.prototype,</p><p> 由图可知，Foo的原型链上并没有Foo.prototype,因此Foo instanceof Foo也就返回false;</p><p> 我们用代码简单的表示一下：</p><pre><code>leftValue = Foo, rightValue = Foo;leftValue = Foo._proto = function.prototype;rightValue = Foo.prototype;//第一次判断leftValue != rightValue;leftValue = Function.prototype._proto_ = Object.prototype//第二次判断leftValue != rightValue;leftValue = Object.prototype　＝null//第三次判断leftValue = null;</code></pre></li><li><p>Foo instanceof Object</p><pre><code>leftValue = Foo, rightValue = ObjectleftValue = Foo.__proto__ = Function.prototyperightValue = Object.prototype// 第一次判断leftValue != rightValueleftValue = Function.prototype.__proto__ = Object.prototype// 第二次判断leftValue === rightValue// 返回 true</code></pre></li><li><p>Foo instanceof Function</p><pre><code>leftValue = Foo, rightValue = FunctionleftValue = Foo.__proto__ = Function.prototyperightValue = Function.prototype// 第一次判断leftValue === rightValue// 返回 true</code></pre></li></ol><p>总结来说：</p><p>我们使用typeof　来判断基本类型是OK的。不过需要注意当用typeof 来判断null类型的问题。如果想要判断一个对象的具体类型可以用instanceof 。但是instanceof　可能也判断不准确，例如一个数组，可以被instanceof　判断为Object。</p><p>所以我们想要比较准确的判断一个数的类型时，可以用Object.prototype.toString.tocall 方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;先介绍下js的基本类型和引用类型&quot;&gt;&lt;a href=&quot;#先介绍下js的基本类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;先介绍下js的基本类型和引用类型&quot;&gt;&lt;/a&gt;先介绍下js的基本类型和引用类型&lt;/h4&gt;&lt;p&gt;基本类型： Null,Und
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css 圣杯布局和双飞翼布局</title>
    <link href="http://qunqunyang.me/2018/05/29/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://qunqunyang.me/2018/05/29/圣杯布局和双飞翼布局/</id>
    <published>2018-05-29T03:11:10.949Z</published>
    <updated>2018-06-15T10:17:28.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><pre><code>按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、但是实现起来还是有区别的。</code></pre><h3 id="1、-圣杯布局："><a href="#1、-圣杯布局：" class="headerlink" title="1、 圣杯布局："></a>1、 圣杯布局：</h3><pre><code>圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，它可以随着容器宽度的变化而自适应宽度。</code></pre><p>在这里，实现了左(100px) 右(100px) 宽度固定，中间自适应，container部分高度保持一致<br>    <img src="https://i.imgur.com/CzxbHrr.png" alt=""></p><p>解释：<br>    html代码中，container包括三部分内容，首先放置middle 然后是left和right()</p><ol><li>顺序需要从middle到left ,right顺序固定，三者都需要float:left,（再加上position:relative相对布局后面会用到）</li><li>middle需要设置宽度100%，占满</li><li>此时middle占满了，要把left拉到最左边。margin-left: -100%;</li><li>这个时候left过来了，但是会占用middle的内容，此时把container设置内边距 padding: 0 100px 0 100px;</li><li>middle内容过来了，left也拉过来了，所以要还原，left要使用相对定位，left： -100px;同理right也要相对定位还原right: -100px;</li><li>到这里大致就好了。 剩余就是高度的问题了。可以加上min-height使用。 </li></ol><p>好了，这里上代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;css3&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.container1 {    padding: 0 100px 0 100px;    min-height: 130px;}.middle {    float: left;    width: 100%;    background: #f00;    min-height: 130px;}.left {    float: left;    position: relative;    left: -100px;    background: #ccc;    width: 100px;    margin-left: -100%;    min-height: 130px;}.right {    float: left;    position: relative;    background: #588;    width: 100px;    margin-left: -100px;    right: -100px;    min-height: 130px;}&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;layout1&quot;&gt;    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2、-双飞翼布局"><a href="#2、-双飞翼布局" class="headerlink" title="2、 双飞翼布局"></a>2、 双飞翼布局</h3><pre><code>如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。这个布局的实现思路是，先把最重要的身体部分放好，然后再将翅膀移动到适当的地方.其实跟上边的圣杯布局差不多的，当然也可以改动一下（自己想想有哪些不同吧）恩，这里有一只鸟~左翅sub有200px,右翅extra..220px.. 身体main自适应未知</code></pre><p><img src="https://i.imgur.com/KCw8DEO.png" alt=""></p><p>1.html代码中，main要放最前边，sub  extra</p><p>2.将main  sub  extra 都float:left</p><p>3.将main占满 width:100%</p><p>4.此时main占满了，所以要把sub拉到最左边，使用margin-left:-100%  同理 extra使用margin-left:-220px</p><p>（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）</p><p>5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。</p><p>给main增加一个内层div– main-inner, 然后margin:0 220px 0 200px</p><p>6.main正确展示</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;css3&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.container2 {    /*padding: 0 100px 0 100px;*/}.main {    float: left;    width: 100%;    min-height: 130px;}.main-middle {    margin: 0 100px 0 100px;    background: #f00;}.left {    float: left;    background: #ccc;    width: 100px;    margin-left: -100%;    min-height: 130px;}.right {    float: left;    background: #588;    width: 100px;    margin-left: -100px;    min-height: 130px;}&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;container2&quot;&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;main-middle&quot;&gt;main---        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;left--- &lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;right--- &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="完结！"><a href="#完结！" class="headerlink" title="完结！"></a>完结！</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、
但是实现起来还是有区别的。

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 单页面微信分享(hash模式)</title>
    <link href="http://qunqunyang.me/2018/05/16/vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%88%86%E4%BA%AB/"/>
    <id>http://qunqunyang.me/2018/05/16/vue单页面分享/</id>
    <published>2018-05-16T07:32:00.792Z</published>
    <updated>2018-05-16T07:32:00.801Z</updated>
    
    <content type="html"><![CDATA[<p> vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。</p><p> 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样当自己拼值时（如“？userId=123”）则需要取第二个问号后的值。之前无论如何都取不到自己拼在路径后的值，复制链接后才发现，微信默默地给加了一个问号和其他参数在其中。</p><p> 坑点2： 如果在公众号中浏览一个页面，直接都是由路由跳转的。但浏览者从分享窗口进入后，再去浏览别的页面 在别的页面按照正常路由跳转到其他页面去分享时 始终是首次进入的页面。</p><h4 id="以下有两种方法"><a href="#以下有两种方法" class="headerlink" title="以下有两种方法"></a>以下有两种方法</h4><pre><code>1： 使用微信自定义分享    分享链接 通过获取url赋值2： vue单页面跳转的时候    1） this.$router.push({ name: &apos;home&apos;, params: { userId: wise }})    2） let url = `#/report/BWDaily?hash=${hash}&amp;lang=${this.lang}&amp;type=${this.type}`;    window.location.href= url;</code></pre><p>第一种方法： 实践不可用</p><p>第二种方法： 实践可用。目前还没找到其根本原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。&lt;/p&gt;
&lt;p&gt; 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>es6箭头函数和普通函数的区别</title>
    <link href="http://qunqunyang.me/2018/05/16/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://qunqunyang.me/2018/05/16/es6箭头函数和普通函数的区别/</id>
    <published>2018-05-16T07:32:00.789Z</published>
    <updated>2018-05-16T09:05:58.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-写法："><a href="#1、-写法：" class="headerlink" title="1、 写法："></a>1、 写法：</h3><pre><code>箭头函数：var a = &gt;{        console.log(b)    }普通函数：    function a(){        console.log(b)    }</code></pre><h3 id="2-箭头函数不能作为构造函数"><a href="#2-箭头函数不能作为构造函数" class="headerlink" title="2. 箭头函数不能作为构造函数"></a>2. 箭头函数不能作为构造函数</h3><pre><code>var a =() =&gt;{    console.log(b); } var b = new a(); //TypeError  a is not a constructor</code></pre><h3 id="3-箭头函数不绑定arguments-取而代之用rest参数…解决。"><a href="#3-箭头函数不绑定arguments-取而代之用rest参数…解决。" class="headerlink" title="3.箭头函数不绑定arguments,取而代之用rest参数…解决。"></a>3.箭头函数不绑定arguments,取而代之用rest参数…解决。</h3><pre><code>function A(a){    console.log(arguments)}var B = (b) =&gt;{    console.log(arguments);  }var C = (...c) =&gt;{    console.log(c)}A(1);B(2);  //arguments is not definedC(3);</code></pre><h3 id="4-箭头函数会捕获其所在上下文的this值，作为自己的this值。"><a href="#4-箭头函数会捕获其所在上下文的this值，作为自己的this值。" class="headerlink" title="4.箭头函数会捕获其所在上下文的this值，作为自己的this值。"></a>4.箭头函数会捕获其所在上下文的this值，作为自己的this值。</h3><pre><code>var Obj = {    a: 10,    b: function(){        console.log(this.a);    },    c: function(){        return ()=&gt;{            console.log(this.a);        }    }}Obj.b();Obj.c()();</code></pre><h3 id="5-使用call-和-apply-调用；"><a href="#5-使用call-和-apply-调用；" class="headerlink" title="5.使用call() 和 apply()调用；"></a>5.使用call() 和 apply()调用；</h3><pre><code>通过call()和apply()方法调用一个函数时。只是传入了参数而已，对this并没有什么影响。var Obj = {    a: 10,    b: function(n){        var f = (v) =&gt; v+this.a        return f(n)    },    c: function(n){        var f = (v) =&gt; v+this.a        var m = {a:20};        return f.call(m,n)    }}console.log(Obj.b(1)); //11console.log(Obj.c(1)); //11</code></pre><h3 id="6-箭头函数没有原型属性。"><a href="#6-箭头函数没有原型属性。" class="headerlink" title="6.箭头函数没有原型属性。"></a>6.箭头函数没有原型属性。</h3><pre><code>var a =() =&gt;{    return 1;}function b(){    return 2;}console.log(a.prototype); //undefinedconsole.log(b.prototype); // object{...}</code></pre><h3 id="7-箭头函数不能换行"><a href="#7-箭头函数不能换行" class="headerlink" title="7.箭头函数不能换行"></a>7.箭头函数不能换行</h3><pre><code>var a = () =&gt;{}</code></pre><h2 id="函数的this指向问题："><a href="#函数的this指向问题：" class="headerlink" title="函数的this指向问题："></a>函数的this指向问题：</h2><pre><code>箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()普通函数的this指向调用它的那个对象</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-写法：&quot;&gt;&lt;a href=&quot;#1、-写法：&quot; class=&quot;headerlink&quot; title=&quot;1、 写法：&quot;&gt;&lt;/a&gt;1、 写法：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;箭头函数：
var a = &amp;gt;{
        console.log(b)
   
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>页面的重绘和重排</title>
    <link href="http://qunqunyang.me/2018/04/16/%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>http://qunqunyang.me/2018/04/16/页面的重绘和重排/</id>
    <published>2018-04-16T11:31:44.426Z</published>
    <updated>2018-04-16T11:31:44.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-重绘-（Repaint）"><a href="#1-重绘-（Repaint）" class="headerlink" title="1. 重绘 （Repaint）"></a>1. 重绘 （Repaint）</h3><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，<br>使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</p><h3 id="2-重排-Reflow"><a href="#2-重排-Reflow" class="headerlink" title="2.重排 (Reflow)"></a>2.重排 (Reflow)</h3><pre><code>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局和重排。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-重绘-（Repaint）&quot;&gt;&lt;a href=&quot;#1-重绘-（Repaint）&quot; class=&quot;headerlink&quot; title=&quot;1. 重绘 （Repaint）&quot;&gt;&lt;/a&gt;1. 重绘 （Repaint）&lt;/h3&gt;&lt;p&gt;重绘是一个元素外观的改变所触发的浏览器行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript 面向对象</title>
    <link href="http://qunqunyang.me/2018/04/16/%E7%BB%A7%E6%89%BF/"/>
    <id>http://qunqunyang.me/2018/04/16/继承/</id>
    <published>2018-04-16T11:31:44.424Z</published>
    <updated>2018-04-16T11:31:44.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack4.5+vue 踩坑记录</title>
    <link href="http://qunqunyang.me/2018/04/16/webpack4.5+vue/"/>
    <id>http://qunqunyang.me/2018/04/16/webpack4.5+vue/</id>
    <published>2018-04-16T11:31:44.423Z</published>
    <updated>2018-04-16T11:31:44.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-最新版本的webpack"><a href="#1-最新版本的webpack" class="headerlink" title="1. 最新版本的webpack"></a>1. 最新版本的webpack</h3><pre><code>配置项： 最近在搭建新的框架，以前的项目webpack版本太低了，就准备升级一下。这一升级不得了，遇到了好多问题。</code></pre><h3 id="2-vue"><a href="#2-vue" class="headerlink" title="2.vue"></a>2.vue</h3><pre><code>目录项    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-最新版本的webpack&quot;&gt;&lt;a href=&quot;#1-最新版本的webpack&quot; class=&quot;headerlink&quot; title=&quot;1. 最新版本的webpack&quot;&gt;&lt;/a&gt;1. 最新版本的webpack&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;配置项： 最近在搭建新的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6和ES7</title>
    <link href="http://qunqunyang.me/2018/04/16/es6%E5%92%8Ces7/"/>
    <id>http://qunqunyang.me/2018/04/16/es6和es7/</id>
    <published>2018-04-16T11:31:44.422Z</published>
    <updated>2018-04-16T11:31:44.423Z</updated>
    
    <content type="html"><![CDATA[<h4 id="首先说下es6语法糖"><a href="#首先说下es6语法糖" class="headerlink" title="首先说下es6语法糖"></a>首先说下es6语法糖</h4><ol><li><p>let</p></li><li><p>const</p></li><li><p>箭头函数</p></li><li><p>解构赋值</p></li><li><p>promise</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;首先说下es6语法糖&quot;&gt;&lt;a href=&quot;#首先说下es6语法糖&quot; class=&quot;headerlink&quot; title=&quot;首先说下es6语法糖&quot;&gt;&lt;/a&gt;首先说下es6语法糖&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;let&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;const&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>过去的贰零壹柒年（魚丁系）</title>
    <link href="http://qunqunyang.me/2018/01/28/%E9%B1%BC%E4%B8%81%E7%B3%BB/"/>
    <id>http://qunqunyang.me/2018/01/28/鱼丁系/</id>
    <published>2018-01-28T07:35:42.567Z</published>
    <updated>2018-01-28T08:44:09.432Z</updated>
    
    <content type="html"><![CDATA[<p>首先为什么叫魚丁系呢。</p><p>分别取蘇打綠的一个偏旁。</p><p>2017年过的好快。过的像天气时好时坏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先为什么叫魚丁系呢。&lt;/p&gt;
&lt;p&gt;分别取蘇打綠的一个偏旁。&lt;/p&gt;
&lt;p&gt;2017年过的好快。过的像天气时好时坏。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器</title>
    <link href="http://qunqunyang.me/2017/12/26/css/"/>
    <id>http://qunqunyang.me/2017/12/26/css/</id>
    <published>2017-12-26T06:29:33.576Z</published>
    <updated>2017-12-26T06:29:33.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="此处遇到浏览器问题"><a href="#此处遇到浏览器问题" class="headerlink" title="此处遇到浏览器问题"></a>此处遇到浏览器问题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;此处遇到浏览器问题&quot;&gt;&lt;a href=&quot;#此处遇到浏览器问题&quot; class=&quot;headerlink&quot; title=&quot;此处遇到浏览器问题&quot;&gt;&lt;/a&gt;此处遇到浏览器问题&lt;/h3&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>flag</title>
    <link href="http://qunqunyang.me/2017/12/26/http%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/"/>
    <id>http://qunqunyang.me/2017/12/26/http请求和响应/</id>
    <published>2017-12-26T03:50:42.190Z</published>
    <updated>2018-01-28T08:44:09.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、user-agent"><a href="#一、user-agent" class="headerlink" title="一、user-agent"></a>一、user-agent</h3><h3 id="看一下Chrome的User-Agent"><a href="#看一下Chrome的User-Agent" class="headerlink" title="看一下Chrome的User-Agent"></a>看一下Chrome的User-Agent</h3><h3 id="这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko"><a href="#这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko" class="headerlink" title="这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko"></a>这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko</h3><ul><li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</li><li>看一下火狐的User-Agent<br>可以看出来，该Firefox为Windows平台的发布版，内核为Firefox的自家内核Gecko</li><li>User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 </li><li>Firefox/30.0</li><li>看一下Mac上的Safari</li><li>看出来，兼容了Mozilla，为Mac系统的发布版，采用自家的Webkit内核(Apple)</li><li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) </li><li></li><li><p>AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14</p></li><li><p>最后是IE的User-Agent</p><p>看出来，兼容了Mozilla，采用兼容模式的IE10，采用自家的Trident内核</p></li><li>User-Agent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)<ul><li>模拟移动设备</li></ul></li><li><p>我们这里可以模拟一个移动设备来查看一下，显示效果，模拟设备，Galaxy Note II ，通过该设备向服务端发送请求</p></li><li><p>请求标头，</p></li><li>User-Agent:Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li></ul><p>二、host  主机域名，或ip地址</p><p>三、accept</p><p>四、refer</p><p>五、gzip</p><p>六、ttransfer-encoding</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、user-agent&quot;&gt;&lt;a href=&quot;#一、user-agent&quot; class=&quot;headerlink&quot; title=&quot;一、user-agent&quot;&gt;&lt;/a&gt;一、user-agent&lt;/h3&gt;&lt;h3 id=&quot;看一下Chrome的User-Agent&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>text</title>
    <link href="http://qunqunyang.me/2017/12/26/%E5%A4%9A%E7%BB%88%E7%AB%AF/"/>
    <id>http://qunqunyang.me/2017/12/26/多终端/</id>
    <published>2017-12-26T03:50:42.183Z</published>
    <updated>2017-12-26T03:50:42.184Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webstorm 打开没有项目目录</title>
    <link href="http://qunqunyang.me/2017/12/26/webtorm%E7%9B%AE%E5%BD%95%E6%B6%88%E5%A4%B1/"/>
    <id>http://qunqunyang.me/2017/12/26/webtorm目录消失/</id>
    <published>2017-12-26T03:50:42.173Z</published>
    <updated>2017-12-26T03:50:42.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示："><a href="#不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：" class="headerlink" title="不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示："></a>不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：</h3><p><img src="http://i.imgur.com/hdPspdH.png" alt=""></p><h3 id="连续出现好几次了。依旧记不住在此记录一下！"><a href="#连续出现好几次了。依旧记不住在此记录一下！" class="headerlink" title="连续出现好几次了。依旧记不住在此记录一下！"></a>连续出现好几次了。依旧记不住在此记录一下！</h3><h4 id="问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。"><a href="#问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。" class="headerlink" title="问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。"></a>问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。</h4><pre><code>解决办法：{1.关掉webstorm；2.删除.idea文件夹（如果隐藏，请设置显示隐藏文件夹）；3.重新新建项目；}</code></pre><p>OK！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：&quot;&gt;&lt;a href=&quot;#不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：&quot; class=&quot;headerlink&quot; title=&quot;不知道操作什么了，准备提交代码的时候忽然找不到目录了。如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊一聊git</title>
    <link href="http://qunqunyang.me/2017/04/01/git%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA/"/>
    <id>http://qunqunyang.me/2017/04/01/git默认行为/</id>
    <published>2017-04-01T02:21:50.825Z</published>
    <updated>2018-01-28T08:03:04.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Git-push与pull的默认行为"><a href="#1-Git-push与pull的默认行为" class="headerlink" title="1. Git push与pull的默认行为"></a>1. Git push与pull的默认行为</h3><p> 一直以来对git push与git pull命令的默认行为感觉混乱，今天抽空总结下。</p><p>git push 通常在一个本地新建分支。git checkout -b develop,在develop分支commit了代码之后。<br>如果直接执行git push命令，develop分支将不会被push到远程仓库（但此时git push操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的push.default默认行为，下文将会逐一详解）</p><h6 id="因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。"><a href="#因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。" class="headerlink" title="因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。"></a>因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。</h6><p>当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行git push命令会有什么效果呢？</p><p>如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:</p><ol><li>develop分支中本地新增的commit被push到远程仓库</li><li><p>push失败，并收到git如下的警告</p><p>  fatal: The current branch new has no upstream branch.<br>  To push the current branch and set the remote as upstream, use</p><p>  git push –set-upstream origin develop</p></li></ol><p>为什么git版本不同会有两种不同的push行为？</p><p>因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为’matching’，2.0之后则被更改为了’simple’。</p><p>我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config –global push.default ‘option’改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。</p><p>push.default 有以下几个可选值：<br>nothing, current, upstream, simple, matching</p><p>其用途分别为：</p><pre><code>nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。current - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。upstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。simple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。matching - push所有本地和远程两端都存在的同名分支。</code></pre><p>因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。</p><p>upstream &amp; downstream<br>说到这里，需要解释一下git中的upstream到底是什么：</p><pre><code>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。</code></pre><p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。</p><h3 id="2-git-pull"><a href="#2-git-pull" class="headerlink" title="2. git pull"></a>2. git pull</h3><p>弄清楚git push的默认行为后，再来看看git pull。</p><p>当我们未指定当前分支的upstream时，通常git pull操作会得到如下的提示：</p><pre><code>There is no tracking information for the current branch.  Please specify which branch you want to merge with.  See git-pull(1) for detailsgit pull &lt;remote&gt; &lt;branch&gt;</code></pre><p>If you wish to set tracking information for this branch you can do so with:</p><pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; new1</code></pre><p>git pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p><p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p><pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; develop  // 或者git push --set-upstream origin develop </code></pre><p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作</p><pre><code>[branch &quot;develop&quot;]    remote = origin    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?</code></pre><p>或者通过command-line直接设置：</p><pre><code>git config branch.develop.merge refs/heads/develop  </code></pre><p>这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去merge origin/develop；如果指定了upstream分支，则会忽略config中的merge默认配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Git-push与pull的默认行为&quot;&gt;&lt;a href=&quot;#1-Git-push与pull的默认行为&quot; class=&quot;headerlink&quot; title=&quot;1. Git push与pull的默认行为&quot;&gt;&lt;/a&gt;1. Git push与pull的默认行为&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
</feed>
