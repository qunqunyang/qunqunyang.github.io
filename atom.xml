<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangqun</title>
  
  <subtitle>平凡的人生，不平凡的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qunqunyang.me/"/>
  <updated>2018-12-24T04:56:14.385Z</updated>
  <id>http://qunqunyang.me/</id>
  
  <author>
    <name>qunqunyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>过去的贰零壹柒年（魚丁系）</title>
    <link href="http://qunqunyang.me/2018/12/24/%E9%B1%BC%E4%B8%81%E7%B3%BB/"/>
    <id>http://qunqunyang.me/2018/12/24/鱼丁系/</id>
    <published>2018-12-24T04:56:14.385Z</published>
    <updated>2018-12-24T04:56:14.385Z</updated>
    
    <content type="html"><![CDATA[<p>首先为什么叫魚丁系呢。</p><p>分别取蘇打綠的一个偏旁。</p><p>2017年过的好快。过的像天气时好时坏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先为什么叫魚丁系呢。&lt;/p&gt;
&lt;p&gt;分别取蘇打綠的一个偏旁。&lt;/p&gt;
&lt;p&gt;2017年过的好快。过的像天气时好时坏。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>页面的重绘和重排</title>
    <link href="http://qunqunyang.me/2018/12/24/%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>http://qunqunyang.me/2018/12/24/页面的重绘和重排/</id>
    <published>2018-12-24T04:56:14.385Z</published>
    <updated>2018-12-24T04:56:14.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-重绘-（Repaint）"><a href="#1-重绘-（Repaint）" class="headerlink" title="1. 重绘 （Repaint）"></a>1. 重绘 （Repaint）</h3><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，<br>使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</p><h3 id="2-重排-Reflow"><a href="#2-重排-Reflow" class="headerlink" title="2.重排 (Reflow)"></a>2.重排 (Reflow)</h3><pre><code>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局和重排。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-重绘-（Repaint）&quot;&gt;&lt;a href=&quot;#1-重绘-（Repaint）&quot; class=&quot;headerlink&quot; title=&quot;1. 重绘 （Repaint）&quot;&gt;&lt;/a&gt;1. 重绘 （Repaint）&lt;/h3&gt;&lt;p&gt;重绘是一个元素外观的改变所触发的浏览器行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈typeof 和instanceof的区别</title>
    <link href="http://qunqunyang.me/2018/12/24/%E6%B5%85%E8%B0%88%20typeof%20%E5%92%8C%20instanceof%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://qunqunyang.me/2018/12/24/浅谈 typeof 和 instanceof的区别/</id>
    <published>2018-12-24T04:56:14.384Z</published>
    <updated>2018-12-24T04:56:14.384Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先介绍下js的基本类型和引用类型"><a href="#先介绍下js的基本类型和引用类型" class="headerlink" title="先介绍下js的基本类型和引用类型"></a>先介绍下js的基本类型和引用类型</h4><p>基本类型： Null,Undefined,Boolean ,Number和String</p><p>引用类型：  Object、Array、RegExp、Date、Function</p><h4 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h4><p>相同点： 都是用来判断一个变量是什么类型的。</p><p>区别：<br>typeof是一元运算放在一个运算数之前可以是任意类型。</p><p>typeof 一般只能返回以下几种类型：Number,String,Boolean,Function, Object,Null,Undefined. Symbol </p><pre><code>我们可以使用typeof 来判断一个变量是否存在，如if(typeof a !== &apos;undefined&apos;){alert(&quot;a&quot;)}; 最好不要使用if(a) 如果a不存在会报错。对于array和null等特殊对象使用typeof 都会返回object。</code></pre><p>判断一个变量的类型常常会用typeof，在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象它都会返回object。</p><pre><code>let s = new String(&apos;abc&apos;);typeof s === &apos;object&apos;// trues instanceof String // true</code></pre><p>此时就需要用到instanceof 来判断。</p><h4 id="typeof的原理："><a href="#typeof的原理：" class="headerlink" title="typeof的原理："></a>typeof的原理：</h4><p>我们可以想想js在底层是怎么存储数据的类型信息呢。js的变量的底层实现。</p><p>其实：js在底层存储变量的时候。会在变量的机器码的低位1-3位存储其类型信息。</p><pre><code>000 对象010 浮点数100 字符串110 布尔1 整数</code></pre><p>但是对与null和undefined来说，这两个值的存储信息是有点特殊的。</p><pre><code>null 所有机器码均为0undefined: 用-2^30 整数来表示。</code></pre><p>所以判断 typeof null的时候就出现问题了。因为null的机器码，因此就被当作了对象来对待。</p><p>如果用instanceof 来判断的话。</p><pre><code>null instanceof null   //TypeError: Right-hand side of &apos;instanceof&apos; is not an object</code></pre><p>还有一个判断类型的方法</p><pre><code>Object.prototype.toString.call(1) //&quot;[object, Number]&quot;其他类型以此类推</code></pre><h4 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h4><p>下面介绍 instanceof<br>instanceof 主要是判断一个实例是否属于某种类型。</p><p>1.</p><pre><code>let person  = function(){}let nichol = new person();nichol instanceof person  //true</code></pre><p>2.</p><pre><code>let person = function(){}let person_per = function(){}person_per.prototype = new peroson()let nichol = new  person_per();nichol instanceof person; //truenichol instanceof person_per ;  //true </code></pre><p>这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p><pre><code>function new_instance_of(leftVaule, rightVaule) {    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值    while (true) {        if (leftVaule === null) {            return false;        }        if (leftVaule === rightProto) {            return true;        }        leftVaule = leftVaule.__proto__    }}</code></pre><p>instanceof的实现原理大致就是只要右侧变量的prototype在左侧变量的原型链上即可。</p><p>因此 instanceof在查找的过程中会遍历左侧的原型链，直到找到右侧变量的prototype,如果查找失败就会返回false,告诉我们左侧变量并非是右侧变量的实例、</p><p>举个栗子：</p><pre><code>function foo(){}function instanceof Object //truefunction instanceof function //trueObject instanceof Object //truefoo instanceof Object //truefoo instanceof foo //falsefoo instanceof function //true</code></pre><p>下面我们来一一解释其结果为什么这样：<br>这就涉及到javascript的继承原理<br>关于原型继承的原理，我简单用一张图来表示<br><img src="https://i.imgur.com/X44Z17j.png" alt=""></p><p>每个javascript对象都有一个隐式的<em>proto</em> 原型属性。而显示属性是prototype, 只有object.prototype.<em>proto</em>属性在未修改的情况下为null值。</p><p>根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。</p><ol><li><p>object instanceof object</p><p>  由图可知，Object的prototype属性是Object.prototype,而由于Object本身是一个函数，由function所创建。</p><p>  所有Object.<em>proto</em>的值是Function.prototype,而Function.prototype的<em>proto</em>属性是Object.prorotype，</p><p>  所有可能判断出 object instanceof object 的结果是true.</p><pre><code>leftValue = Object._proto_ = Function.prototype;rightValue = Object.prototype//第一次判断leftValue != rightValueleftValue = Function.prototype._proto_ = Object._prototype//第二次判断leftValue = rightValue</code></pre></li></ol><p>Function instanceof Function和 Function instanceof Object的运行过程与Object instanceof Object类似。故不再详说</p><ol><li><p>Foo instanceof Foo</p><p> Foo函数的prototype 属性是Foo.prototype, 而foo的<em>proto</em>属性是Function.prototype,</p><p> 由图可知，Foo的原型链上并没有Foo.prototype,因此Foo instanceof Foo也就返回false;</p><p> 我们用代码简单的表示一下：</p><pre><code>leftValue = Foo, rightValue = Foo;leftValue = Foo._proto = function.prototype;rightValue = Foo.prototype;//第一次判断leftValue != rightValue;leftValue = Function.prototype._proto_ = Object.prototype//第二次判断leftValue != rightValue;leftValue = Object.prototype　＝null//第三次判断leftValue = null;</code></pre></li><li><p>Foo instanceof Object</p><pre><code>leftValue = Foo, rightValue = ObjectleftValue = Foo.__proto__ = Function.prototyperightValue = Object.prototype// 第一次判断leftValue != rightValueleftValue = Function.prototype.__proto__ = Object.prototype// 第二次判断leftValue === rightValue// 返回 true</code></pre></li><li><p>Foo instanceof Function</p><pre><code>leftValue = Foo, rightValue = FunctionleftValue = Foo.__proto__ = Function.prototyperightValue = Function.prototype// 第一次判断leftValue === rightValue// 返回 true</code></pre></li></ol><p>总结来说：</p><p>我们使用typeof　来判断基本类型是OK的。不过需要注意当用typeof 来判断null类型的问题。如果想要判断一个对象的具体类型可以用instanceof 。但是instanceof　可能也判断不准确，例如一个数组，可以被instanceof　判断为Object。</p><p>所以我们想要比较准确的判断一个数的类型时，可以用Object.prototype.toString.tocall 方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;先介绍下js的基本类型和引用类型&quot;&gt;&lt;a href=&quot;#先介绍下js的基本类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;先介绍下js的基本类型和引用类型&quot;&gt;&lt;/a&gt;先介绍下js的基本类型和引用类型&lt;/h4&gt;&lt;p&gt;基本类型： Null,Und
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript 面向对象</title>
    <link href="http://qunqunyang.me/2018/12/24/%E7%BB%A7%E6%89%BF/"/>
    <id>http://qunqunyang.me/2018/12/24/继承/</id>
    <published>2018-12-24T04:56:14.384Z</published>
    <updated>2018-12-24T04:56:14.384Z</updated>
    
    <content type="html"><![CDATA[<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多终端</title>
    <link href="http://qunqunyang.me/2018/12/24/%E5%A4%9A%E7%BB%88%E7%AB%AF/"/>
    <id>http://qunqunyang.me/2018/12/24/多终端/</id>
    <published>2018-12-24T04:56:14.384Z</published>
    <updated>2018-12-24T06:25:58.283Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css 圣杯布局和双飞翼布局</title>
    <link href="http://qunqunyang.me/2018/12/24/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://qunqunyang.me/2018/12/24/圣杯布局和双飞翼布局/</id>
    <published>2018-12-24T04:56:14.384Z</published>
    <updated>2018-12-24T04:56:14.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><pre><code>按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、但是实现起来还是有区别的。</code></pre><h3 id="1、-圣杯布局："><a href="#1、-圣杯布局：" class="headerlink" title="1、 圣杯布局："></a>1、 圣杯布局：</h3><pre><code>圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，它可以随着容器宽度的变化而自适应宽度。</code></pre><p>在这里，实现了左(100px) 右(100px) 宽度固定，中间自适应，container部分高度保持一致<br>    <img src="https://i.imgur.com/CzxbHrr.png" alt=""></p><p>解释：<br>    html代码中，container包括三部分内容，首先放置middle 然后是left和right()</p><ol><li>顺序需要从middle到left ,right顺序固定，三者都需要float:left,（再加上position:relative相对布局后面会用到）</li><li>middle需要设置宽度100%，占满</li><li>此时middle占满了，要把left拉到最左边。margin-left: -100%;</li><li>这个时候left过来了，但是会占用middle的内容，此时把container设置内边距 padding: 0 100px 0 100px;</li><li>middle内容过来了，left也拉过来了，所以要还原，left要使用相对定位，left： -100px;同理right也要相对定位还原right: -100px;</li><li>到这里大致就好了。 剩余就是高度的问题了。可以加上min-height使用。 </li></ol><p>好了，这里上代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;css3&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.container1 {    padding: 0 100px 0 100px;    min-height: 130px;}.middle {    float: left;    width: 100%;    background: #f00;    min-height: 130px;}.left {    float: left;    position: relative;    left: -100px;    background: #ccc;    width: 100px;    margin-left: -100%;    min-height: 130px;}.right {    float: left;    position: relative;    background: #588;    width: 100px;    margin-left: -100px;    right: -100px;    min-height: 130px;}&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;layout1&quot;&gt;    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2、-双飞翼布局"><a href="#2、-双飞翼布局" class="headerlink" title="2、 双飞翼布局"></a>2、 双飞翼布局</h3><pre><code>如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。这个布局的实现思路是，先把最重要的身体部分放好，然后再将翅膀移动到适当的地方.其实跟上边的圣杯布局差不多的，当然也可以改动一下（自己想想有哪些不同吧）恩，这里有一只鸟~左翅sub有200px,右翅extra..220px.. 身体main自适应未知</code></pre><p><img src="https://i.imgur.com/KCw8DEO.png" alt=""></p><p>1.html代码中，main要放最前边，sub  extra</p><p>2.将main  sub  extra 都float:left</p><p>3.将main占满 width:100%</p><p>4.此时main占满了，所以要把sub拉到最左边，使用margin-left:-100%  同理 extra使用margin-left:-220px</p><p>（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）</p><p>5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。</p><p>给main增加一个内层div– main-inner, 然后margin:0 220px 0 200px</p><p>6.main正确展示</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;css3&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.container2 {    /*padding: 0 100px 0 100px;*/}.main {    float: left;    width: 100%;    min-height: 130px;}.main-middle {    margin: 0 100px 0 100px;    background: #f00;}.left {    float: left;    background: #ccc;    width: 100px;    margin-left: -100%;    min-height: 130px;}.right {    float: left;    background: #588;    width: 100px;    margin-left: -100px;    min-height: 130px;}&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;container2&quot;&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;main-middle&quot;&gt;main---        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;left--- &lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;right--- &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="完结！"><a href="#完结！" class="headerlink" title="完结！"></a>完结！</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;按我的理解，其实双飞翼布局和圣杯布局的实现，目的都是左右两栏固定宽度，中间部分自适应、
但是实现起来还是有区别的。

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>promise</title>
    <link href="http://qunqunyang.me/2018/12/24/promise%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://qunqunyang.me/2018/12/24/promise的前世今生/</id>
    <published>2018-12-24T04:56:14.383Z</published>
    <updated>2018-12-24T06:43:58.663Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webstorm 打开没有项目目录</title>
    <link href="http://qunqunyang.me/2018/12/24/webtorm%E7%9B%AE%E5%BD%95%E6%B6%88%E5%A4%B1/"/>
    <id>http://qunqunyang.me/2018/12/24/webtorm目录消失/</id>
    <published>2018-12-24T04:56:14.383Z</published>
    <updated>2018-12-24T04:56:14.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示："><a href="#不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：" class="headerlink" title="不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示："></a>不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：</h3><p><img src="http://i.imgur.com/hdPspdH.png" alt=""></p><h3 id="连续出现好几次了。依旧记不住在此记录一下！"><a href="#连续出现好几次了。依旧记不住在此记录一下！" class="headerlink" title="连续出现好几次了。依旧记不住在此记录一下！"></a>连续出现好几次了。依旧记不住在此记录一下！</h3><h4 id="问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。"><a href="#问题原因：webstorm自动生成的配置文件-idea-modules-xml损坏（就是我一开始乱搞，删项目）。" class="headerlink" title="问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。"></a>问题原因：webstorm自动生成的配置文件 .idea/modules.xml损坏（就是我一开始乱搞，删项目）。</h4><pre><code>解决办法：{1.关掉webstorm；2.删除.idea文件夹（如果隐藏，请设置显示隐藏文件夹）；3.重新新建项目；}</code></pre><p>OK！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：&quot;&gt;&lt;a href=&quot;#不知道操作什么了，准备提交代码的时候忽然找不到目录了。如图显示：&quot; class=&quot;headerlink&quot; title=&quot;不知道操作什么了，准备提交代码的时候忽然找不到目录了。如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack4.5+vue 踩坑记录</title>
    <link href="http://qunqunyang.me/2018/12/24/webpack4.5+vue/"/>
    <id>http://qunqunyang.me/2018/12/24/webpack4.5+vue/</id>
    <published>2018-12-24T04:56:14.383Z</published>
    <updated>2018-12-24T04:56:14.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-最新版本的webpack"><a href="#1-最新版本的webpack" class="headerlink" title="1. 最新版本的webpack"></a>1. 最新版本的webpack</h3><pre><code>配置项： 最近在搭建新的框架，以前的项目webpack版本太低了，就准备升级一下。这一升级不得了，遇到了好多问题。</code></pre><h3 id="2-vue"><a href="#2-vue" class="headerlink" title="2.vue"></a>2.vue</h3><pre><code>目录项    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-最新版本的webpack&quot;&gt;&lt;a href=&quot;#1-最新版本的webpack&quot; class=&quot;headerlink&quot; title=&quot;1. 最新版本的webpack&quot;&gt;&lt;/a&gt;1. 最新版本的webpack&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;配置项： 最近在搭建新的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js的基本类型和引用类型</title>
    <link href="http://qunqunyang.me/2018/12/24/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://qunqunyang.me/2018/12/24/js的基本类型和引用类型/</id>
    <published>2018-12-24T04:56:14.383Z</published>
    <updated>2018-12-24T04:56:14.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、基本类型和引用类型的区别："><a href="#1、基本类型和引用类型的区别：" class="headerlink" title="1、基本类型和引用类型的区别："></a>1、基本类型和引用类型的区别：</h3><p>1） 基本类型： </p><p>2）  引用类型</p><p>3） 两者区别</p><p>4） 操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、基本类型和引用类型的区别：&quot;&gt;&lt;a href=&quot;#1、基本类型和引用类型的区别：&quot; class=&quot;headerlink&quot; title=&quot;1、基本类型和引用类型的区别：&quot;&gt;&lt;/a&gt;1、基本类型和引用类型的区别：&lt;/h3&gt;&lt;p&gt;1） 基本类型： &lt;/p&gt;
&lt;p&gt;2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 单页面微信分享(hash模式)</title>
    <link href="http://qunqunyang.me/2018/12/24/vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%88%86%E4%BA%AB/"/>
    <id>http://qunqunyang.me/2018/12/24/vue单页面分享/</id>
    <published>2018-12-24T04:56:14.383Z</published>
    <updated>2018-12-24T04:56:14.383Z</updated>
    
    <content type="html"><![CDATA[<p> vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。</p><p> 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样当自己拼值时（如“？userId=123”）则需要取第二个问号后的值。之前无论如何都取不到自己拼在路径后的值，复制链接后才发现，微信默默地给加了一个问号和其他参数在其中。</p><p> 坑点2： 如果在公众号中浏览一个页面，直接都是由路由跳转的。但浏览者从分享窗口进入后，再去浏览别的页面 在别的页面按照正常路由跳转到其他页面去分享时 始终是首次进入的页面。</p><h4 id="以下有两种方法"><a href="#以下有两种方法" class="headerlink" title="以下有两种方法"></a>以下有两种方法</h4><pre><code>1： 使用微信自定义分享    分享链接 通过获取url赋值2： vue单页面跳转的时候    1） this.$router.push({ name: &apos;home&apos;, params: { userId: wise }})    2） let url = `#/report/BWDaily?hash=${hash}&amp;lang=${this.lang}&amp;type=${this.type}`;    window.location.href= url;</code></pre><p>第一种方法： 实践不可用</p><p>第二种方法： 实践可用。目前还没找到其根本原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; vue hash模式微信分享时安卓可以正常分享，ios分享的页面始终是打开的第一个页面的问题。&lt;/p&gt;
&lt;p&gt; 坑点1： 因为我的项目为单页式应用，并且采用了Vue中的hash模式，因此项目路径中带有#号的部分，微信可能会在其前面加一个？号（不知未来还会不会有变化）。这样
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>flag</title>
    <link href="http://qunqunyang.me/2018/12/24/http%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/"/>
    <id>http://qunqunyang.me/2018/12/24/http请求和响应/</id>
    <published>2018-12-24T04:56:14.382Z</published>
    <updated>2018-12-24T04:56:14.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、user-agent"><a href="#一、user-agent" class="headerlink" title="一、user-agent"></a>一、user-agent</h3><h3 id="看一下Chrome的User-Agent"><a href="#看一下Chrome的User-Agent" class="headerlink" title="看一下Chrome的User-Agent"></a>看一下Chrome的User-Agent</h3><h3 id="这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko"><a href="#这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko" class="headerlink" title="这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko"></a>这里可以看出来，该Chrome是MAC的发布版，采用了兼容了Mozilla，Safari，内核兼容AppleWebkit和Gecko</h3><ul><li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</li><li>看一下火狐的User-Agent<br>可以看出来，该Firefox为Windows平台的发布版，内核为Firefox的自家内核Gecko</li><li>User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 </li><li>Firefox/30.0</li><li>看一下Mac上的Safari</li><li>看出来，兼容了Mozilla，为Mac系统的发布版，采用自家的Webkit内核(Apple)</li><li>User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) </li><li></li><li><p>AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14</p></li><li><p>最后是IE的User-Agent</p><p>看出来，兼容了Mozilla，采用兼容模式的IE10，采用自家的Trident内核</p></li><li>User-Agent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)<ul><li>模拟移动设备</li></ul></li><li><p>我们这里可以模拟一个移动设备来查看一下，显示效果，模拟设备，Galaxy Note II ，通过该设备向服务端发送请求</p></li><li><p>请求标头，</p></li><li>User-Agent:Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li></ul><p>二、host  主机域名，或ip地址</p><p>三、accept</p><p>四、refer</p><p>五、gzip</p><p>六、ttransfer-encoding</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、user-agent&quot;&gt;&lt;a href=&quot;#一、user-agent&quot; class=&quot;headerlink&quot; title=&quot;一、user-agent&quot;&gt;&lt;/a&gt;一、user-agent&lt;/h3&gt;&lt;h3 id=&quot;看一下Chrome的User-Agent&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://qunqunyang.me/2018/12/24/hello-world/"/>
    <id>http://qunqunyang.me/2018/12/24/hello-world/</id>
    <published>2018-12-24T04:56:14.382Z</published>
    <updated>2018-12-24T04:56:14.382Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊一聊git</title>
    <link href="http://qunqunyang.me/2018/12/24/git%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA/"/>
    <id>http://qunqunyang.me/2018/12/24/git默认行为/</id>
    <published>2018-12-24T04:56:14.382Z</published>
    <updated>2018-12-24T04:56:14.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Git-push与pull的默认行为"><a href="#1-Git-push与pull的默认行为" class="headerlink" title="1. Git push与pull的默认行为"></a>1. Git push与pull的默认行为</h3><p> 一直以来对git push与git pull命令的默认行为感觉混乱，今天抽空总结下。</p><p>git push 通常在一个本地新建分支。git checkout -b develop,在develop分支commit了代码之后。<br>如果直接执行git push命令，develop分支将不会被push到远程仓库（但此时git push操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的push.default默认行为，下文将会逐一详解）</p><h6 id="因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。"><a href="#因此我们至少需要显式指定将要推送的分支名，例如git-push-origin-develop，才能将本地新分支推送到远程仓库。" class="headerlink" title="因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。"></a>因此我们至少需要显式指定将要推送的分支名，例如git push origin develop，才能将本地新分支推送到远程仓库。</h6><p>当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行git push命令会有什么效果呢？</p><p>如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:</p><ol><li>develop分支中本地新增的commit被push到远程仓库</li><li><p>push失败，并收到git如下的警告</p><p>  fatal: The current branch new has no upstream branch.<br>  To push the current branch and set the remote as upstream, use</p><p>  git push –set-upstream origin develop</p></li></ol><p>为什么git版本不同会有两种不同的push行为？</p><p>因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为’matching’，2.0之后则被更改为了’simple’。</p><p>我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config –global push.default ‘option’改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。</p><p>push.default 有以下几个可选值：<br>nothing, current, upstream, simple, matching</p><p>其用途分别为：</p><pre><code>nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。current - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。upstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。simple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。matching - push所有本地和远程两端都存在的同名分支。</code></pre><p>因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。</p><p>upstream &amp; downstream<br>说到这里，需要解释一下git中的upstream到底是什么：</p><pre><code>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。</code></pre><p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。</p><h3 id="2-git-pull"><a href="#2-git-pull" class="headerlink" title="2. git pull"></a>2. git pull</h3><p>弄清楚git push的默认行为后，再来看看git pull。</p><p>当我们未指定当前分支的upstream时，通常git pull操作会得到如下的提示：</p><pre><code>There is no tracking information for the current branch.  Please specify which branch you want to merge with.  See git-pull(1) for detailsgit pull &lt;remote&gt; &lt;branch&gt;</code></pre><p>If you wish to set tracking information for this branch you can do so with:</p><pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; new1</code></pre><p>git pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p><p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p><pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; develop  // 或者git push --set-upstream origin develop </code></pre><p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作</p><pre><code>[branch &quot;develop&quot;]    remote = origin    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?</code></pre><p>或者通过command-line直接设置：</p><pre><code>git config branch.develop.merge refs/heads/develop  </code></pre><p>这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去merge origin/develop；如果指定了upstream分支，则会忽略config中的merge默认配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Git-push与pull的默认行为&quot;&gt;&lt;a href=&quot;#1-Git-push与pull的默认行为&quot; class=&quot;headerlink&quot; title=&quot;1. Git push与pull的默认行为&quot;&gt;&lt;/a&gt;1. Git push与pull的默认行为&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Object类的常用方法 （二）</title>
    <link href="http://qunqunyang.me/2018/12/24/Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://qunqunyang.me/2018/12/24/Object类的常用方法（二）/</id>
    <published>2018-12-24T04:56:14.381Z</published>
    <updated>2018-12-24T04:56:14.381Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>续上文Object类的常用方法（一）</p><p>上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()<br>本篇文章会有点枯燥捏！</p></blockquote><p>下面就按顺序排了</p><h5 id="5、-Object-entries"><a href="#5、-Object-entries" class="headerlink" title="5、 Object.entries:"></a>5、 Object.entries:</h5><blockquote><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p></blockquote><pre><code>Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。参数： Object.entries(obj), 其中 obj 可以返回其可枚举属性的键值对的对象。返回值： 给定对象自身可枚举属性的键值对数组。</code></pre><p>举个栗子：</p><pre><code>const obj = { foo: &apos;bar&apos;, baz: 42 };console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]// array like objectconst obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };console.log(Object.entries(obj)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]// array like object with random key orderingconst anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };console.log(Object.entries(anObj)); // [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]// getFoo is property which isn&apos;t enumerableconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });myObj.foo = &apos;bar&apos;;console.log(Object.entries(myObj)); // [ [&apos;foo&apos;, &apos;bar&apos;] ]// non-object argument will be coerced to an objectconsole.log(Object.entries(&apos;foo&apos;)); // [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]// iterate through key-value gracefullyconst obj = { a: 5, b: 7, c: 9 };for (const [key, value] of Object.entries(obj)) {  console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;}// Or, using array extrasObject.entries(obj).forEach(([key, value]) =&gt; {console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;});</code></pre><h5 id="6、-Object-create"><a href="#6、-Object-create" class="headerlink" title="6、 Object.create:"></a>6、 Object.create:</h5><blockquote><p><code>Object.create()</code> 方法会使用指定的原型对象及其属性去创建一个新的对象</p><p>Object.create(proto[, propertiesObject])</p><p>其中参数proto为一个对象，作为新创建对象的原型</p><p>propertiesObject: 对象，可选参数，为新创建的对象指定属性对象。</p></blockquote><p><strong> 注意，使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。</strong></p><p>来看一个简单的例子：</p><pre><code>// 基类function Site() {  this.name = &apos;Site&apos;;  this.domain = &apos;domain&apos;;}Site.prototype.create = function(name, domain) {  this.name = name;  this.domain = domain;};// 子类function Itbilu() {  Site.call(this); //调用基类的构造函数}// 继承父类Itbilu.prototype = Object.create(Site.prototype);// 创建类实例var itbilu = new Itbilu();itbilu instanceof Site;  // truetbilu instanceof Itbilu;  // trueitbilu.create(&apos;IT笔录&apos;, &apos;itbilu.com&apos;);itbilu.name;    // &apos;IT笔录&apos;itbilu.domain;  // &apos;itbilu.com&apos;</code></pre><p>使用 <code>Object.create()</code> 的 propertyObject参数</p><pre><code>var o;// 创建一个原型为null的空对象o = Object.create(null);o = {};// 以字面量方式创建的空对象就相当于:o = Object.create(Object.prototype);o = Object.create(Object.prototype, {  // foo会成为所创建对象的数据属性  foo: {     writable:true,    configurable:true,    value: &quot;hello&quot;   },  // bar会成为所创建对象的访问器属性  bar: {    configurable: false,    get: function() { return 10 },    set: function(value) {      console.log(&quot;Setting `o.bar` to&quot;, value);    }  }});</code></pre><h5 id="7、Object-defineProperty"><a href="#7、Object-defineProperty" class="headerlink" title="7、Object.defineProperty"></a>7、Object.defineProperty</h5><pre><code>语法： Object.defineProperty(obj, prop, descriptor)参数：     obj：必需。目标对象     prop：必需。需定义或修改的属性的名字    descriptor：必需。目标属性所拥有的特性返回值： 传入函数的对象。即第一个参数obj</code></pre><p>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历</p><p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p><p>数据描述：<br>当修改或者定义对象的某个属性的时候，给这个属性添加一些特性：</p><pre><code>var obj = {    test:&quot;hello&quot;}//对象已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});//对象新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});</code></pre><p>数据描述中的属性都是可选的。看一下每个设置的作用。</p><p>1) value： 属性对应的值,可以使任意类型的值，默认为undefined</p><pre><code>var obj = {};//第一种情况，不设置value属性。Object.defineProperty(obj,&quot;newKey&quot;,{})console.log(obj.newKey);   //undefined    //第二种 设置value属性Object.defineProperty(obj,&quot;newKey&quot;,{    value： &apos;hello&apos;})console.log(obj.newKey);   //hello    </code></pre><p>2) writable<br>    属性的值是否可以被重写。设置为true可以被重写，设置为false,不可被重写。 默认为false</p><pre><code>var obj = {}//第一种情况：writable设置为false，不能重写。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //hello//第二种情况：writable设置为true，可以重写Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //change value</code></pre><p>3)  enumerable<br>此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p><pre><code>var obj = {}//第一种情况：enumerable设置为false，不能被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false});//枚举对象的属性for( var attr in obj ){    console.log( attr );  }//第二种情况：enumerable设置为true，可以被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:true});//枚举对象的属性for( var attr in obj ){    console.log( attr );  //newKey}</code></pre><p>4)  configurable</p><pre><code>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。这个属性起到两个作用：1. 目标属性是否可以使用delete删除2. 目标属性是否可以再次设置特性    //-----------------测试目标属性是否能被删除------------------------    var obj = {}    //第一种情况：configurable设置为false，不能被删除。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:false    });    //删除属性    delete obj.newKey;    console.log( obj.newKey ); //hello    //第二种情况：configurable设置为true，可以被删除。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:true    });    //删除属性    delete obj.newKey;    console.log( obj.newKey ); //undefined    //-----------------测试是否可以再次修改特性------------------------    var obj = {}    //第一种情况：configurable设置为false，不能再次修改特性。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:false    });    //重新修改特性    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:true,        enumerable:true,        configurable:true    });    console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey    //第二种情况：configurable设置为true，可以再次修改特性。    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:false,        enumerable:false,        configurable:true    });    //重新修改特性    Object.defineProperty(obj,&quot;newKey&quot;,{        value:&quot;hello&quot;,        writable:true,        enumerable:true,        configurable:true    });    console.log( obj.newKey ); //hello</code></pre><p>除了给新特性的属性设置特性，也可以给已有的属性设置特性。</p><pre><code>//定义对象的时候添加的属性，是可删除、可重写、可枚举的。var obj = {    test:&quot;hello&quot;}//改写值obj.test = &apos;change value&apos;;console.log( obj.test ); //&apos;change value&apos;Object.defineProperty(obj,&quot;test&quot;,{    writable:false})//再次改写值obj.test = &apos;change value again&apos;;console.log( obj.test ); //依然是：&apos;change value&apos;</code></pre><p><strong> 提示： 一旦使用<code>Object.defineProperty()</code>给对象添加属性，那么如果不设置属性的特性，那么configrable,enumerable,writable这些值都是默认的false。</strong></p><pre><code>var obj = {};定义新属性后，这个属性的特性中，都是默认为false。这就导致了newKey这个是不能重写，不能枚举，不能再次设置特性。//Object.defineProperty(obj,&apos;newKey&apos;,{});//设置值obj.newKey = &apos;hello&apos;;console.log(obj.newKey);  //undefined//枚举for( var attr in obj ){    console.log(attr);}</code></pre><p>特性总结：</p><blockquote><p>value: 设置属性的值<br>writable: 值是否可以重写。true | false<br>enumerable: 目标属性是否可以被枚举。true | false<br>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false</p><h5 id="8、Object-hasOwnProperty（）"><a href="#8、Object-hasOwnProperty（）" class="headerlink" title="8、Object.hasOwnProperty（）"></a>8、Object.hasOwnProperty（）</h5><p>用于知识一个对象自身是否具有指定名称的属性，如果有返回true， 如果没有返回false。</p></blockquote><pre><code>语法 ：object.hasOwnProperty(propertyName)propertyName：指定的属性名称返回值： hasOwnProperty（）返回的值是Boolean类型。如果对象Object具有名称为propertyName的属性，则返回true    ,否则返回false。</code></pre><p>此方法不会检查对象的原型链中是否存在此属性，该属性只有是对象本身的一个成员才会返回true。</p><p>举个例子：</p><pre><code>function isHas(){    this.name = &apos;today&apos;,    this.week = &apos;wendsday&apos;,    this.sayHi = function(){        document.writeln(&apos;今天是&apos;+this.name);    }}var obj = {    mood = &apos;happy&apos;,    sayHello = function(){        document.writeln(&apos;今天的心情是&apos;+this.mood);    }}</code></pre><p>//使用对象obj覆盖Site本身的prototype属性</p><pre><code>isHas.prototype = obj;var h = new isHas();document.writeln(s.hasOwnProperty(&apos;name&apos;)); //truedocument.writeln(s.hasOwnProperty(&apos;sayHi&apos;)); //true//以下属性继承自原型链，所以为falsedocument.writeln(s.hasOwnProperty(&apos;mood&apos;)); //falsedocument.writeln(s.hasOwnProperty(&apos;sayHello&apos;)); //false// 想要查看对象(包括原型链)是否具备指定的属性，可以使用in操作符document.writeln(&apos;mood&apos; in s); //truedocument.writeln(&apos;sayHello&apos; in s); //true</code></pre><p> 完结！ 后续有更新再添加！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;续上文Object类的常用方法（一）&lt;/p&gt;
&lt;p&gt;上一篇文章介绍了Object.assign(),Object.is()，Object.keys()，Object.values()&lt;br&gt;本篇文章会有点枯燥捏！&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>es6箭头函数和普通函数的区别</title>
    <link href="http://qunqunyang.me/2018/12/24/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://qunqunyang.me/2018/12/24/es6箭头函数和普通函数的区别/</id>
    <published>2018-12-24T04:56:14.381Z</published>
    <updated>2018-12-24T04:56:14.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-写法："><a href="#1、-写法：" class="headerlink" title="1、 写法："></a>1、 写法：</h3><pre><code>箭头函数：var a = &gt;{        console.log(b)    }普通函数：    function a(){        console.log(b)    }</code></pre><h3 id="2-箭头函数不能作为构造函数"><a href="#2-箭头函数不能作为构造函数" class="headerlink" title="2. 箭头函数不能作为构造函数"></a>2. 箭头函数不能作为构造函数</h3><pre><code>var a =() =&gt;{    console.log(b); } var b = new a(); //TypeError  a is not a constructor</code></pre><h3 id="3-箭头函数不绑定arguments-取而代之用rest参数…解决。"><a href="#3-箭头函数不绑定arguments-取而代之用rest参数…解决。" class="headerlink" title="3.箭头函数不绑定arguments,取而代之用rest参数…解决。"></a>3.箭头函数不绑定arguments,取而代之用rest参数…解决。</h3><pre><code>function A(a){    console.log(arguments)}var B = (b) =&gt;{    console.log(arguments);  }var C = (...c) =&gt;{    console.log(c)}A(1);B(2);  //arguments is not definedC(3);</code></pre><h3 id="4-箭头函数会捕获其所在上下文的this值，作为自己的this值。"><a href="#4-箭头函数会捕获其所在上下文的this值，作为自己的this值。" class="headerlink" title="4.箭头函数会捕获其所在上下文的this值，作为自己的this值。"></a>4.箭头函数会捕获其所在上下文的this值，作为自己的this值。</h3><pre><code>var Obj = {    a: 10,    b: function(){        console.log(this.a);    },    c: function(){        return ()=&gt;{            console.log(this.a);        }    }}Obj.b();Obj.c()();</code></pre><h3 id="5-使用call-和-apply-调用；"><a href="#5-使用call-和-apply-调用；" class="headerlink" title="5.使用call() 和 apply()调用；"></a>5.使用call() 和 apply()调用；</h3><pre><code>通过call()和apply()方法调用一个函数时。只是传入了参数而已，对this并没有什么影响。var Obj = {    a: 10,    b: function(n){        var f = (v) =&gt; v+this.a        return f(n)    },    c: function(n){        var f = (v) =&gt; v+this.a        var m = {a:20};        return f.call(m,n)    }}console.log(Obj.b(1)); //11console.log(Obj.c(1)); //11</code></pre><h3 id="6-箭头函数没有原型属性。"><a href="#6-箭头函数没有原型属性。" class="headerlink" title="6.箭头函数没有原型属性。"></a>6.箭头函数没有原型属性。</h3><pre><code>var a =() =&gt;{    return 1;}function b(){    return 2;}console.log(a.prototype); //undefinedconsole.log(b.prototype); // object{...}</code></pre><h3 id="7-箭头函数不能换行"><a href="#7-箭头函数不能换行" class="headerlink" title="7.箭头函数不能换行"></a>7.箭头函数不能换行</h3><pre><code>var a = () =&gt;{}</code></pre><h2 id="函数的this指向问题："><a href="#函数的this指向问题：" class="headerlink" title="函数的this指向问题："></a>函数的this指向问题：</h2><pre><code>箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()普通函数的this指向调用它的那个对象</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-写法：&quot;&gt;&lt;a href=&quot;#1、-写法：&quot; class=&quot;headerlink&quot; title=&quot;1、 写法：&quot;&gt;&lt;/a&gt;1、 写法：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;箭头函数：
var a = &amp;gt;{
        console.log(b)
   
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6和ES7</title>
    <link href="http://qunqunyang.me/2018/12/24/es6%E5%92%8Ces7/"/>
    <id>http://qunqunyang.me/2018/12/24/es6和es7/</id>
    <published>2018-12-24T04:56:14.381Z</published>
    <updated>2018-12-24T04:56:14.381Z</updated>
    
    <content type="html"><![CDATA[<h4 id="首先说下es6语法糖"><a href="#首先说下es6语法糖" class="headerlink" title="首先说下es6语法糖"></a>首先说下es6语法糖</h4><ol><li><p>let</p></li><li><p>const</p></li><li><p>箭头函数</p></li><li><p>解构赋值</p></li><li><p>promise</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;首先说下es6语法糖&quot;&gt;&lt;a href=&quot;#首先说下es6语法糖&quot; class=&quot;headerlink&quot; title=&quot;首先说下es6语法糖&quot;&gt;&lt;/a&gt;首先说下es6语法糖&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;let&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;const&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器</title>
    <link href="http://qunqunyang.me/2018/12/24/css/"/>
    <id>http://qunqunyang.me/2018/12/24/css/</id>
    <published>2018-12-24T04:56:14.381Z</published>
    <updated>2018-12-24T04:56:14.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="此处遇到浏览器问题"><a href="#此处遇到浏览器问题" class="headerlink" title="此处遇到浏览器问题"></a>此处遇到浏览器问题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;此处遇到浏览器问题&quot;&gt;&lt;a href=&quot;#此处遇到浏览器问题&quot; class=&quot;headerlink&quot; title=&quot;此处遇到浏览器问题&quot;&gt;&lt;/a&gt;此处遇到浏览器问题&lt;/h3&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Object类的常用方法 （一）</title>
    <link href="http://qunqunyang.me/2018/12/24/Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://qunqunyang.me/2018/12/24/Object类的常用方法/</id>
    <published>2018-12-24T04:56:14.381Z</published>
    <updated>2018-12-24T04:56:14.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote><p>js中对Object的一些操作</p><p>对象是值： 成对的名称（字符串）和值（任何值），其中名称通过冒号与值分隔；    </p></blockquote><h4 id="一-、创建对象的方法："><a href="#一-、创建对象的方法：" class="headerlink" title="一 、创建对象的方法："></a>一 、创建对象的方法：</h4><ol><li><p>字面量形式：</p><p> var obj = {</p><pre><code>a:1，b:2</code></pre><p> }; </p></li><li><p>对象实例</p><p> var obj = new Object();</p></li><li><p>构造函数形式</p><pre><code>function employee(name,job,born) {    this.name=name;    this.job=job;    this.born=born;}var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);// employee {name: &quot;Bill Gates&quot;, job: &quot;Engineer&quot;, born: 1985} </code></pre></li></ol><ol><li><p>es6 class模式</p><p> //定义类</p><pre><code>class point = {    constructor(x,y){        this.x = x;        this.y = y;        };    //定义方法    tostring(){        return &apos;(&apos;+this.x+&apos;,&apos;+this.y+&apos;)&apos;;    }    multiplication(){        return this.x*this.y    }    test(){        return &apos;1234567890&apos;    }}console.log(point.name)//Point （name属性总是返回紧跟在class关键字后面的类名。）// 实例化并调用（实例化和调用方法同es5相同）var x = new Point(5, 6)console.log(x.toString(), &apos;相乘结果：&apos; + x.multiplication(), x.test())// (5, 6) 相乘结果：30 1231354654// 快速添加方法到原型上 （如下图，直接可添加到原型）Object.assign(Point.prototype, {    dosomething() { },    toValue() { }});console.log(Point.prototype)</code></pre></li></ol><h4 id="二、Object的常用方法"><a href="#二、Object的常用方法" class="headerlink" title="二、Object的常用方法"></a>二、Object的常用方法</h4><h5 id="1、-Object-assign：-浅拷贝复制"><a href="#1、-Object-assign：-浅拷贝复制" class="headerlink" title="1、 Object.assign：  浅拷贝复制"></a>1、 Object.assign：  浅拷贝复制</h5><blockquote><p>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 Object.assign(target, …sources)</p></blockquote><p>参数:</p><p>target:目标对象;sources:源对象;返回值:目标对象</p><ol><li><p>复制一个对象，并不会影响原对象</p><pre><code>var obj = {a:1};var copy = Object.assign({},obj);console.log(copy) // {a:1}</code></pre></li><li><p>合并对象</p><pre><code>//object.assign(obj, obj2)  obj2是源对象，obj 是目标对象，返回目标对象var obj = { a: 1 };var obj2={b:2};console.log(Object.assign(obj,obj2)===obj);  //true，返回目标对象console.log(obj);       //{a:1,b:2} obj的值已被更改</code></pre></li><li><p>如果目标对象和源对象有相同的属性，则会被覆盖，后面的对象会覆盖掉前面的属性</p></li></ol><pre><code>var obj = { a: 1 };var obj1 = {a:2,b:5};var obj2={b:2};Object.assign(obj,obj1,obj2);  //{a:2,b:2}</code></pre><ol><li><p>当assign只有一个对象时，则直接返回这个对象，不做任何操作</p></li><li><p>Object.assign是浅拷贝，copy的是一个对象的引用</p><pre><code>var obj1 = { a: 0 , b: { c: 0}};var obj2 = Object.assign({}, obj1);obj1.b.c=5;console.log(obj2)       //{a:0,b:{c:5}};</code></pre><p> 当我们在改变obj1的值时，并没有想改变obj2，但obj2的值也发生了改变，这违背了我们的想法</p></li><li><p>深拷贝</p><pre><code>var obj = { a: 0 , b: { c: 0}};var obj2 = JSON.parse(JSON.stringify(obj));obj.a = 4;obj.b.c = 4;console.log(obj2)   //{ a: 0 , b: { c: 0}}</code></pre></li></ol><h5 id="2、-Object-is"><a href="#2、-Object-is" class="headerlink" title="2、 Object.is()"></a>2、 Object.is()</h5><p>判断两个值是否是同一个值 </p><p>参数:  Object.is(value1,value2)</p><p>value1:需要比较的第一个值。 value2:需要比较的第二个值。 返回值:表示两个参数是否相同的Boolean</p><pre><code>Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;);     // trueObject.is(window, window);   // trueObject.is(&apos;foo&apos;, &apos;bar&apos;);     // falseObject.is([], []);           // falsevar test = { a: 1 };Object.is(test, test);       // trueObject.is(null, null);       // true// 特例Object.is(0, -0);            // falseObject.is(-0, -0);           // trueObject.is(NaN, 0/0);         // true    </code></pre><h5 id="3、-Object-keys"><a href="#3、-Object-keys" class="headerlink" title="3、 Object.keys()"></a>3、 Object.keys()</h5><blockquote><p>这个方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p></blockquote><pre><code>1）数组对象    var arr=[1,2,3];                Object.keys(arr)         //  [&quot;0&quot;, &quot;1&quot;, &quot;2”]2） object对象    var obj = { foo: &quot;bar&quot;, baz: 42 };    Object.keys(obj)        //  [&quot;foo&quot;, &quot;baz”](3)类数组，对象    var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c”};    Object.keys(obj)       // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] </code></pre><h5 id="4、-Object-values"><a href="#4、-Object-values" class="headerlink" title="4、 Object.values()"></a>4、 Object.values()</h5><blockquote><p>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for..in循环相同，返回的对象的value值，与Object.key()相反</p></blockquote><pre><code>var obj = {a:1,b:2,c:3};console.log(Object.values(obj))   //  [1, 2, 3]var obj ={0:&apos;a&apos;,1:&apos;b&apos;,2:&apos;c&apos;};console.log(Object.values(obj)).       //  a,b,cvar obj={100:&apos;a&apos;,10:&apos;b&apos;,1:&apos;1&apos;};console.log(Object.values(obj)).   // [&quot;1&quot;, &quot;b&quot;, &quot;a&quot;]</code></pre><h5 id="待更新："><a href="#待更新：" class="headerlink" title="待更新："></a>待更新：</h5><h5 id="5、-Object-entries"><a href="#5、-Object-entries" class="headerlink" title="5、 Object.entries:"></a>5、 Object.entries:</h5><h5 id="6、-Object-create"><a href="#6、-Object-create" class="headerlink" title="6、 Object.create:"></a>6、 Object.create:</h5><h5 id="7、-Object-defineProperties"><a href="#7、-Object-defineProperties" class="headerlink" title="7、 Object.defineProperties"></a>7、 Object.defineProperties</h5><h5 id="8、Object-defineProperty"><a href="#8、Object-defineProperty" class="headerlink" title="8、Object.defineProperty"></a>8、Object.defineProperty</h5><h5 id="9、Object-hasOwnProperty"><a href="#9、Object-hasOwnProperty" class="headerlink" title="9、Object.hasOwnProperty"></a>9、Object.hasOwnProperty</h5><p>其他不常用方法：</p><pre><code>1、Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。2、Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。3、Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。4、Object.isSealed() 方法判断一个对象是否是密封的（sealed）。5、Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;js中对Object的一些操作&lt;/p&gt;
&lt;p&gt;对象是值： 成对的名称（字符串）和值（任何值），其中名称通过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://qunqunyang.me/2018/09/21/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://qunqunyang.me/2018/09/21/跨域/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2018-12-24T06:43:29.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天讨论前端常见的跨域方案："><a href="#今天讨论前端常见的跨域方案：" class="headerlink" title="今天讨论前端常见的跨域方案："></a>今天讨论前端常见的跨域方案：</h3><p>首先什么是跨域：</p><pre><code>跨域指的是一个域下的脚本或文档试图去请求另一个域下的资源：</code></pre><p>什么是同源策略？</p><pre><code>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。同源策略限制一下场景：1） Cookie、LocalStorage 和 IndexDB 无法读取2） DOM 和 Js对象无法获得3） AJAX 请求不能发送</code></pre><p>跨域的解决方案：</p><pre><code>1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域</code></pre><p>一：通过jsonp跨域<br>为了减轻web服务器的负载，我们把js,css,img,等静态资源放在另一个独立域名的服务器上，在浏览器中通过相应的标签从不同域名下加载资源，而被浏览器允许，基于此原理我们可以通过动态创建script，再请求一个带参网址实现实现跨域通信。<br>    1：原生实现：</p><pre><code>&lt;script&gt;    var script = document.createElement(&apos;script&apos;);    script.type = &apos;text/javascript&apos;;    script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;;    document.head.appendChild(script);    //回调函数    function onBack(res){        alert(JSON.stringify(res));    };&lt;/script&gt;服务端返回如下：onBack({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;})2：jquery +ajax    $.ajax({        url: &apos;http://www.domain2.com:8080/login&apos;,        type: &apos;get&apos;,        dataType: &apos;jsonp&apos;,  // 请求方式为jsonp        jsonpCallback: &quot;onBack&quot;,    // 自定义回调函数名        data: {}    });3: vue.js    this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;,{        params:{},        jsonp:onBack,    }).then((res) =&gt; {        console.log(res);    })后端node.js代码事例：var querystring = require(querystring);var http = require(&apos;http&apos;);var server = http.createServer();server.on(&apos;request&apos;,function(req,res) =&gt;{    var params = qs.parse(req.url.split(&apos;?&apos;)[1]);    var fn = params.callback;    // jsonp返回设置    res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/javascript&apos; });    res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);    res.end();})jsonp的缺点实现get一种请求；</code></pre><p>二：document.domain+iframe跨域<br>此方案仅限主域相同，子域不同的跨域应用场景。<br>实现原理： 两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1.）父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">http://www.domain.com/a.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &apos;domain.com&apos;;</span><br><span class="line">    var user = &apos;admin&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2.）子窗口：(<a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &apos;domain.com&apos;;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>三： location.hash+iframe</p><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &apos;#user=admin&apos;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&apos;data from c.html ---&gt; &apos; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3.）c.html：(<a href="http://www.domain1.com/c.html" target="_blank" rel="noopener">http://www.domain1.com/c.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>四： window.name + iframe跨域</p><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&apos;http://www.domain2.com/b.html&apos;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.）proxy.html：(<a href="http://www.domain1.com/proxy" target="_blank" rel="noopener">http://www.domain1.com/proxy</a>….</p><p>中间代理页，与a.html同域，内容为空即可。</p><p>3.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &apos;This is domain2 data!&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><p>五、 postMessage跨域</p><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &apos;aym&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">        alert(&apos;data from domain2 ---&gt; &apos; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">        alert(&apos;data from domain1 ---&gt; &apos; + e.data);</span><br><span class="line"></span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>六、 跨域资源共享（CORS）</p><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p><p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><p>1、 前端设置：<br>1.）原生ajax</p><p>// 前端设置是否带cookie<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">var xhr = new XMLHttpRequest(); //</span><br><span class="line">IE8/9需用window.XDomainRequest兼容 </span><br><span class="line">    </span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">xhr.send(&apos;user=admin&apos;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2.）jQuery ajax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: true    // 前端设置是否带cookie</span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.）vue框架</p><p>a.) axios设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.) vue-resource设置：</span><br><span class="line"></span><br><span class="line">``` Vue.http.options.credentials = true</span><br></pre></td></tr></table></figure><p>2、 服务端设置：<br>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 导入包：import javax.servlet.http.HttpServletResponse;</span><br><span class="line"> * 接口参数中定义：HttpServletResponse response</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&apos;/&apos;</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); </span><br><span class="line"></span><br><span class="line">// 允许前端带认证cookie：启用此项后，上面的域名不能为&apos;*&apos;，必须指定具体的域名，否则浏览器会提示</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); </span><br><span class="line"></span><br><span class="line">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;);</span><br></pre></td></tr></table></figure></p><p>2.）Nodejs后台示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var postData = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    // 数据块接收中</span><br><span class="line">    req.addListener(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 数据接收完毕</span><br><span class="line">    req.addListener(&apos;end&apos;, function() &#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        // 跨域后台设置</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;,     // 后端允许发送Cookie</span><br><span class="line">            &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;,    // 允许访问的域（协议+域名+端口）</span><br><span class="line">            /* </span><br><span class="line">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span><br><span class="line">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span><br><span class="line">             */</span><br><span class="line">            &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;  // HttpOnly的作用是让js无法读取cookie</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(JSON.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure></p><p>七： nginx跨域代理</p><p>1、 nginx配置解决iconfont跨域</p><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、 nginx反向代理接口跨域<br>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.) 前端代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>2.) Nodejs后台示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line"></span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure></p><p>八、 Nodejs中间件代理跨域</p><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><p>1、 非vue框架的跨域（2次跨域）<br>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.）前端代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>2.）中间件服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/&apos;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &apos;http://www.domain2.com:8080&apos;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line"></span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;);</span><br><span class="line">        res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&apos;Proxy server is listen at port 3000...&apos;);</span><br></pre></td></tr></table></figure></p><p>3.）Nodejs后台同（六：nginx）</p><p>2、 vue框架的跨域（1次跨域）</p><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &apos;/login&apos;,</span><br><span class="line">            target: &apos;http://www.domain2.com:8080&apos;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>九、 WebSocket协议跨域<br>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.）前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&apos;http://www.domain2.com:8080&apos;);</span><br><span class="line"></span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&apos;connect&apos;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">        console.log(&apos;data from server: ---&gt; &apos; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&apos;disconnect&apos;, function() &#123; </span><br><span class="line">        console.log(&apos;Server socket has closed.&apos;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>2.）Nodejs socket后台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var socket = require(&apos;socket.io&apos;);</span><br><span class="line"></span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Content-type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br><span class="line"></span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&apos;connection&apos;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">        client.send(&apos;hello：&apos; + msg);</span><br><span class="line">        console.log(&apos;data from client: ---&gt; &apos; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&apos;disconnect&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;Client socket has closed.&apos;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天讨论前端常见的跨域方案：&quot;&gt;&lt;a href=&quot;#今天讨论前端常见的跨域方案：&quot; class=&quot;headerlink&quot; title=&quot;今天讨论前端常见的跨域方案：&quot;&gt;&lt;/a&gt;今天讨论前端常见的跨域方案：&lt;/h3&gt;&lt;p&gt;首先什么是跨域：&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
    
  </entry>
  
</feed>
